# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/importers.EmailImporter.ipynb (unless otherwise specified).

__all__ = ['IMAPClient', 'part_to_str', 'DEFAULT_GMAIL_HOST', 'DEFAULT_GMAIL_INBOX', 'DEFAULT_PORT',
           'get_unique_accounts', 'get_g_attr', 'EmailImporter']

# Cell
import imaplib, email, math
from ..data.schema import Account, EmailMessage, MessageChannel
from ..pod.client import PodClient
from .util import *
from ..data.basic import *
from email import policy
from email.utils import getaddresses
from ..imports import *
from nbdev.showdoc import show_doc

# Cell
DEFAULT_GMAIL_HOST = 'imap.gmail.com'
DEFAULT_GMAIL_INBOX = '"[Gmail]/All Mail"' # Note the double quotes here
DEFAULT_PORT = 993

class IMAPClient():

    def __init__(self, username, app_pw, host=DEFAULT_GMAIL_HOST, port=DEFAULT_PORT, inbox=DEFAULT_GMAIL_INBOX):
        assert username is not None and app_pw is not None
        self.client = imaplib.IMAP4_SSL(host, port=port)
        self.client.login(username, app_pw)
        self.client.select(inbox) # connect to inbox.

    def list_mailboxes(self):
        """Lists all available mailboxes"""
        return self.client.list()

    def get_all_mail_uids(self, from_uid=None):
        """retrieves all mail uids from the selected mailbox"""
        if from_uid == None:
            result, data = self.client.uid('search', None, "ALL") # search and return uids instead
        else:
            # Be wary of the difference between sequence number and UIDs
            result, data = self.client.uid('search', None, "UID " + str(from_uid) + ":*")
        return data[0].split()

    def get_mails(self, uids):
        return [self.get_mail(uid) for uid in uids]

    def get_mail(self, uid):
        """Fetches a mail given a uid, returns (raw_mail, thread_id)"""
        if self.client.host == DEFAULT_GMAIL_HOST:
            # Use Google's threading method, in which every thread has an ID
            result, (data, _) = self.client.uid('fetch', uid, '(RFC822 X-GM-THRID)')
            thread_id = data[0].decode("utf-8").split(" ")[2]
            raw_email = data[1]
            return (raw_email, thread_id)
        else:
            # Threading not yet implemented for IMAP threading
            result, (data, _) = self.client.uid('fetch', uid, '(RFC822)')
            raw_email = data[1]
            return (raw_email, None)

def part_to_str(part):
    # hide
    bytes_ = part.get_payload(decode=True)
    charset = part.get_content_charset('iso-8859-1')
    chars = bytes_.decode(charset, 'replace')
    return chars

def _get_all_parts(part):
    # hide
    payload = part.get_payload()
    if isinstance(payload, list):
        return [x for p in payload for x in _get_all_parts(p)]
    else:
        return [part]

# Cell

# TODO: should probably become a general utility function
def get_unique_accounts(all_mails):
    # hide
    all_accounts = {}
    for email_item in all_mails:
        for edge in email_item.get_all_edges():
            account = edge.traverse(email_item)
            if not account.externalId in all_accounts:
                all_accounts[account.externalId] = account

    for email_item in all_mails:
        for edge in email_item.get_all_edges():
            edge.target = all_accounts[edge.target.externalId]

    return list(all_accounts.values())

# TODO: should probably become a general utility function
def get_g_attr(item, name, data_type, default_value=None):
    # hide
    first_or_default = next((att for att in item.genericAttribute if att.name == name), None)
    if first_or_default == None:
        return default_value
    else:
        if data_type == 'int':
            return first_or_default.intValue
        elif data_type == 'bool':
            return first_or_default.boolValue
        elif data_type == 'float':
            return first_or_default.floatValue
        elif data_type == 'string':
            return first_or_default.stringValue
        elif data_type == 'datetime':
            return first_or_default.stringValue
        else:
            raise Exception(f"datatype {data_type} is not supported")

# Cell

from ..data.schema import *
from ..imports import *
from ..indexers.indexer import test_registration
from .importer import ImporterBase


class EmailImporter(ImporterBase):
    """Imports emails over imap"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.imap_client = None

    def get_data(self, client, indexer_run):
        print('this function is a workaround (this Importer is an Indexer temporarily)')

    def set_imap_client(self, importer_run):
        imap_host = get_g_attr(importer_run, 'host', 'string', DEFAULT_GMAIL_HOST)
        port = get_g_attr(importer_run, 'port', 'int', DEFAULT_PORT)
        assert imap_host is not None and port is not None
        print(f'Using, HOST: {imap_host}, PORT: {port}')

        self.imap_client = IMAPClient(username=importer_run.username,
                                     app_pw=importer_run.password,
                                     host=imap_host,
                                     port=993)

    @staticmethod
    def get_timestamp_from_message(message):
        date = message["date"]
        parsed_time = email.utils.parsedate(date)
        dt = email.utils.parsedate_to_datetime(date)
        timestamp = int(dt.timestamp() * 1000)

        return timestamp

    @staticmethod
    def get_accounts(message, field):
        addresses = getaddresses(message.get_all(field, []))
        return [Account(externalId=address) for name, address in addresses]

    @staticmethod
    def get_content(message):
        """Extracts content from a python email message"""
        maintype = message.get_content_maintype()
        if maintype == 'multipart':

            parts = _get_all_parts(message)
            res = None
            html_parts = [part_to_str(part) for part in parts if part.get_content_type() == "text/html"]
            if len(html_parts) > 0:
                if len(html_parts) > 1:
                    error_msg = "\n AND \n".join(html_parts)
                    print(f"WARNING: FOUND MULTIPLE HTML PARTS IN ONE MESSAGE {error_msg}")
                return html_parts[0]
            else:
                return parts[0].get_payload()

        elif maintype == 'text':
            return message.get_payload()

    @staticmethod
    def get_attachments(message): return list(message.iter_attachments())

    def create_item_from_mail(self, mail, thread_id=None):
        """Creates a schema-item from an existing mail"""
        message = email.message_from_bytes(mail, policy=policy.SMTP)

        message_id, subject = message["message-id"], message["subject"]
        timestamp = self.get_timestamp_from_message(message)

        content = self.get_content(message)
        attachments = self.get_attachments(message)

        email_item = EmailMessage(externalId=message_id, subject=subject, dateSent=timestamp, content=content)

        for a in self.get_accounts(message, 'from'): email_item.add_edge('sender', a)
        for a in self.get_accounts(message, 'to'): email_item.add_edge('receiver', a)
        for a in self.get_accounts(message, 'reply-to'): email_item.add_edge('replyTo', a)

        if thread_id != None:
            email_item.add_edge('messageChannel', MessageChannel(externalId=thread_id))

        return email_item

    def get_mails(self, mail_ids, batch_size=5, importer_run=None, verbose=True, pod_client=None):
        """Gets mails from a list of mail uids. You can pass an importer run and podclient
        to update the progress of the process"""
        mails = []
        n_batches = math.ceil(len(mail_ids) / batch_size)

        for i, batch_ids in enumerate(batch(mail_ids, n=batch_size)):

            for mail, thread_id in self.imap_client.get_mails(mail_ids):
                item = self.create_item_from_mail(mail, thread_id=thread_id)
                if pod_client is not None:
                    if not pod_client.external_id_exists(item):
                        pod_client.create(item)
                        mails.append(item)
                else:
                    mails.append(item)

            progress = (i + 1) / n_batches * 1.0
            self.update_progress(pod_client, importer_run, progress, total=len(mail_ids))

        return mails

    def run(self, importer_run, pod_client=None, verbose=True):
        """This is the main function of the Email importer. It runs the importer given information
        provided in the importer run. if you pass a pod client it will add the new items to the graph."""
        self.set_imap_client(importer_run)
        self.update_run_status(pod_client, importer_run, "running")

        stop_early_at = get_g_attr(importer_run, 'max_number', 'int', 10)

        self.update_progress_message(pod_client, importer_run, "downloading emails", verbose=verbose)
        mail_ids = self.imap_client.get_all_mail_uids()
        all_mails = self.get_mails(mail_ids[:int(stop_early_at)],
                                   importer_run=importer_run,
                                   pod_client=pod_client)

        # TODO: create better way to do this
        self.update_progress_message(pod_client, importer_run, "merging duplicate items", verbose=verbose)
        all_accounts = get_unique_accounts(all_mails)

        self.update_progress_message(pod_client, importer_run, "creating accounts", verbose=verbose)
        for item in all_accounts: pod_client.create(item)

        self.update_progress_message(pod_client, importer_run, "creating threads", verbose=verbose)
        for email_item in all_mails: pod_client.create_edges(email_item.get_all_edges())

        print(f"Finished running {self}")

        self.update_run_status(pod_client, importer_run, "done")
