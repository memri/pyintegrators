# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/gmail.ipynb (unless otherwise specified).

__all__ = ['IMAPClient', 'get_message_content', 'get_addresses_from_message', 'get_timestamp_from_message',
           'create_item_from_mail', 'download_mails', 'merge_duplicate_items', 'GmailImporter']

# Cell

import imaplib, email
from ..data.schema import Account, EmailMessage, MessageChannel
from ..pod.client import PodClient
from email import policy

# Cell

class IMAPClient():

    def __init__(self, username, app_pw, host='imap.gmail.com', inbox='"[Gmail]/All Mail"'):
        self.client = imaplib.IMAP4_SSL(host)
        self.client.login(username, app_pw)
        self.client.select(inbox) # connect to inbox.

    def list_mailboxes(self):
        return self.client.list()

    def get_all_mail_uids(self):
        result, data = self.client.uid('search', None, "ALL") # search and return uids instead
        return data[0].split()

    def get_mail(self, uid):
        result, data = self.client.uid('fetch', uid, '(RFC822)')
        raw_email = data[0][1]
        return raw_email

    def get_all_mails(self, uids):
        res = []
        for uid in tqdm(uids):
            result, data = self.client.uid('fetch', uid, '(RFC822)')
            raw_email = data[0][1]
            res.append(raw_email)
        return res

    def get_x_gm_thrid(self, uid):
        result, data = self.client.uid('fetch', uid, '(X-GM-THRID X-GM-MSGID)')
        return data[0].decode("utf-8").split(" ")[2]

# # @staticmethod
# def part_to_str(part):
#     bytes_ = part.get_payload(decode=True)
#     charset = part.get_content_charset('iso-8859-1')
#     chars = bytes_.decode(charset, 'replace')
#     return chars

# # @staticmethod
# def get_html(email_message_instance):
#     maintype = email_message_instance.get_content_maintype()
#     if maintype == 'multipart':

#         parts = _get_all_parts(email_message_instance)
#         res = None
#         html_parts = [part_to_str(part) for part in parts if part.get_content_type() == "text/html"]
#         if len(html_parts) > 0:
#             if len(html_parts) > 1:
#                 error_msg = "\n AND \n".join(html_parts)
#                 print(f"WARNING: FOUND MULTIPLE HTML PARTS IN ONE MESSAGE {error_msg}")
#             return html_parts[0]
#         else:
#             return parts[0].get_payload()

#     elif maintype == 'text':
#         return email_message_instance.get_payload()

# # @staticmethod
# def _get_all_parts(part):
#     payload = part.get_payload()
#     if isinstance(payload, list):
#         return [x for p in payload for x in _get_all_parts(p)]
#     else:
#         return [part]

def get_message_content(message):
#     content = get_html(message)
#     # TODO: proper escaping here
#     content = content.replace("=3D", "=")

# USED FOR DOWNLOADING ATTACHMENTS
#     for i, x in enumerate(message.iter_attachments()):
#         f = open(f"tmp/gmail/{i}.png", 'wb')
#         f.write(x.get_content())
#         f.close()
    content = message.get_body().get_content()
    attachments = []
    return (content, attachments)

def get_addresses_from_message(message, field):
    if message[field] is None:
        return []
    else:
        return email.utils.getaddresses([message[field]])

def get_timestamp_from_message(message):
    date = message["date"]
    parsed_time = email.utils.parsedate(date)
    dt = email.utils.parsedate_to_datetime(date)
    timestamp = int(dt.timestamp() * 1000)

    return timestamp

# Cell

def create_item_from_mail(mail, thread_id=None):
    # message = email.message_from_string(mail_utf8)
    message = email.message_from_bytes(mail, policy=policy.SMTP)

    message_id = message["message-id"]
    subject = message["subject"]
    timestamp = get_timestamp_from_message(message)

    from_tuples = parse_addresses(message,'from')
    to_tuples = parse_addresses(message,'to')
    reply_to_tuples = parse_addresses(message,'reply-to')

    (content, attachments) = get_message_content(message)
    # importJson = mail_utf8

    # TODO: is dateSent the right way to go? Might differ for whether you're sender or receiver
    # TODO: importJson
    # TODO: MAIL namespace
    email_item = EmailMessage(externalId=message_id, subject=subject, dateSent=timestamp, content=content)

    # Create Edges to accounts
    for name, address in from_tuples:
        address_item = Account(externalId=address)
        email_item.add_edge('sender', address_item)

    for name, address in to_tuples:
        address_item = Account(externalId=address)
        email_item.add_edge('receiver', address_item)

    for name, address in reply_to_tuples:
        address_item = Account(externalId=address)
        email_item.add_edge('replyTo', address_item)

    # Create edge to MessageChannel
    if thread_id != None:
        message_channel = MessageChannel(externalId=thread_id)
        email_item.add_edge('messageChannel', message_channel)

    return email_item

def download_mails(imap_client, gmail_ids, stop_at):
    all_mails = []

    # Download files
    for i, gmail_id in enumerate(gmail_ids):
        if stop_at is not None and i >= stop_at:
            print(f"stopped early at {stop_at}")
            break

        mail = imap_client.get_mail(gmail_id)

        thread_id = imap_client.get_x_gm_thrid(gmail_id)
        item = create_item_from_mail(mail, thread_id=thread_id)
        all_mails.append(item)

    return all_mails

# TODO: should probably become a general utility function
def merge_duplicate_items(all_mails):
    all_accounts = {}
    for email_item in all_mails:
        for edge in email_item.get_all_edges():
            account = edge.traverse(email_item)
            if not account.externalId in all_accounts:
                all_accounts[account.externalId] = account

    for email_item in all_mails:
        for edge in email_item.get_all_edges():
            edge.target = all_accounts[edge.target.externalId]

    return all_accounts

# Cell

from ..data.schema import *
from ..imports import *
from ..indexers.indexer import IndexerBase, test_registration

class GmailImporter(IndexerBase):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def run(self, importer_run, pod_client=None):
        # TODO: Get imap_host from importer_run
        imap_host = 'imap.gmail.com'

        imap_client = IMAPClient(username=importer_run.username,
                                 app_pw=importer_run.password,
                                 host=imap_host)
        gmail_ids = imap_client.get_all_mail_uids()
        all_mails = download_mails(imap_client, gmail_ids, None)

        # Merge email accounts/messageChannels here
        # TODO: create better way to do this
        all_accounts = merge_duplicate_items(all_mails)

        # Create all email and account items
        all_thread_ids = set()
        for email_item in all_mails:
            pod_client.create(email_item)
            all_thread_ids.add(email_item.messageChannel[0].externalId)
        for (external_id, item) in all_accounts.items():
            pod_client.create(item)

        # Create all edges from emails to accounts/messageThreads
        for email_item in all_mails:
            pod_client.create_edges(email_item.get_all_edges())