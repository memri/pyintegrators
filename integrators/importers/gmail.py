# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/importers.GmailImporter.ipynb (unless otherwise specified).

__all__ = ['IMAPClient', 'part_to_str', 'DEFAULT_GMAIL_HOST', 'DEFAULT_GMAIL_INBOX', 'DEFAULT_PORT',
           'get_unique_accounts', 'get_g_attr', 'GmailImporter']

# Cell
import imaplib, email, math
from ..data.schema import Account, EmailMessage, MessageChannel
from ..pod.client import PodClient
from .util import *
from ..data.basic import *
from email import policy
from email.utils import getaddresses

# Cell
DEFAULT_GMAIL_HOST = 'imap.gmail.com'
DEFAULT_GMAIL_INBOX = '"[Gmail]/All Mail"' # Note the double quotes here
DEFAULT_PORT = 993

class IMAPClient():

    def __init__(self, username, app_pw, host=DEFAULT_GMAIL_HOST, port=DEFAULT_PORT, inbox=DEFAULT_GMAIL_INBOX):
        assert username is not None and app_pw is not None
        self.client = imaplib.IMAP4_SSL(host, port=port)
        self.client.login(username, app_pw)
        self.client.select(inbox) # connect to inbox.

    def list_mailboxes(self):
        return self.client.list()

    def get_all_mail_uids(self):
        result, data = self.client.uid('search', None, "ALL") # search and return uids instead
        return data[0].split()

    def get_mails(self, uids):
        return [self.get_mail(uid) for uid in uids]

    def get_mail(self, uid):
        if self.client.host == DEFAULT_GMAIL_HOST:
            # Use Google's threading method, in which every thread has an ID
            result, (data, _) = self.client.uid('fetch', uid, '(RFC822 X-GM-THRID)')
            thread_id = data[0].decode("utf-8").split(" ")[2]
            raw_email = data[1]
            return (raw_email, thread_id)
        else:
            # Threading not yet implemented for IMAP threading
            result, (data, _) = self.client.uid('fetch', uid, '(RFC822)')
            raw_email = data[1]
            return (raw_email, None)

def part_to_str(part):
    bytes_ = part.get_payload(decode=True)
    charset = part.get_content_charset('iso-8859-1')
    chars = bytes_.decode(charset, 'replace')
    return chars

def _get_all_parts(part):
    payload = part.get_payload()
    if isinstance(payload, list):
        return [x for p in payload for x in _get_all_parts(p)]
    else:
        return [part]

# Cell

# TODO: should probably become a general utility function
def get_unique_accounts(all_mails):
    all_accounts = {}
    for email_item in all_mails:
        for edge in email_item.get_all_edges():
            account = edge.traverse(email_item)
            if not account.externalId in all_accounts:
                all_accounts[account.externalId] = account

    for email_item in all_mails:
        for edge in email_item.get_all_edges():
            edge.target = all_accounts[edge.target.externalId]

    return list(all_accounts.values())

# TODO: should probably become a general utility function
def get_g_attr(item, name, data_type, default_value=None):
    first_or_default = next((att for att in item.genericAttribute if att.name == name), None)
    if first_or_default == None:
        return default_value
    else:
        if data_type == 'int':
            return first_or_default.intValue
        elif data_type == 'bool':
            return first_or_default.boolValue
        elif data_type == 'float':
            return first_or_default.floatValue
        elif data_type == 'string':
            return first_or_default.stringValue
        elif data_type == 'datetime':
            return first_or_default.stringValue
        else:
            raise Exception(f"datatype {data_type} is not supported")

# Cell

from ..data.schema import *
from ..imports import *
from ..indexers.indexer import ImporterBase, test_registration

class GmailImporter(ImporterBase):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.imap_client = None

    def get_data(self, client, indexer_run):
        print('this function is a workaround (this Importer is an Indexer temporarily)')

    def set_imap_client(self, importer_run):
        imap_host = get_g_attr(importer_run, 'host', 'string', DEFAULT_GMAIL_HOST)
        port = get_g_attr(importer_run, 'port', 'int', DEFAULT_PORT)
        assert imap_host is not None and port is not None
        print(f'Using, HOST: {imap_host}, PORT: {port}')

        self.imap_client = IMAPClient(username=importer_run.username,
                                     app_pw=importer_run.password,
                                     host=imap_host,
                                     port=993)

    @staticmethod
    def get_timestamp_from_message(message):
        date = message["date"]
        parsed_time = email.utils.parsedate(date)
        dt = email.utils.parsedate_to_datetime(date)
        timestamp = int(dt.timestamp() * 1000)

        return timestamp

    @staticmethod
    def get_accounts(message, field):
        addresses = getaddresses(message.get_all(field, []))
        return [Account(externalId=address) for name, address in addresses]

    @staticmethod
    def get_content(message):
        maintype = message.get_content_maintype()
        if maintype == 'multipart':

            parts = _get_all_parts(message)
            res = None
            html_parts = [part_to_str(part) for part in parts if part.get_content_type() == "text/html"]
            if len(html_parts) > 0:
                if len(html_parts) > 1:
                    error_msg = "\n AND \n".join(html_parts)
                    print(f"WARNING: FOUND MULTIPLE HTML PARTS IN ONE MESSAGE {error_msg}")
                return html_parts[0]
            else:
                return parts[0].get_payload()

        elif maintype == 'text':
            return message.get_payload()

    @staticmethod
    def get_attachments(message): return list(message.iter_attachments())

    def create_item_from_mail(self, mail, thread_id=None):
        """Creates a schema-item from an existing mail"""
        message = email.message_from_bytes(mail, policy=policy.SMTP)

        message_id, subject = message["message-id"], message["subject"]
        timestamp = self.get_timestamp_from_message(message)

        content = self.get_content(message)
        attachments = self.get_attachments(message)

        email_item = EmailMessage(externalId=message_id, subject=subject, dateSent=timestamp, content=content)

        for a in self.get_accounts(message, 'from'): email_item.add_edge('sender', a)
        for a in self.get_accounts(message, 'to'): email_item.add_edge('receiver', a)
        for a in self.get_accounts(message, 'reply-to'): email_item.add_edge('replyTo', a)

        if thread_id != None:
            email_item.add_edge('messageChannel', MessageChannel(externalId=thread_id))

        return email_item

    def get_mails(self, gmail_ids, stop_at=1e9):
        all_mails = []
        batch_size = 5
        n_batches = math.ceil(total_mails/batch_size)
        total_mails = min(len(gmail_ids), stop_at * batch_size)

        # Download files
        for i, batch_ids in enumerate(batch(gmail_ids, n=batch_size)):
            if i >= stop_at:
                print(f"stopped early at {stop_at}")
                break
            # TODO: set progress here
            print(f'PROGRESS: Downloading mail : {i/n_batches * 100.0}% of {total_mails} mails')

            for mail, thread_id in self.imap_client.get_mails(gmail_ids):
                item = self.create_item_from_mail(mail, thread_id=thread_id)
                all_mails.append(item)

        return all_mails

    def run(self, importer_run, pod_client=None):
        self.set_imap_client(importer_run)

        stop_early_at = get_g_attr(importer_run, 'max_number', 'int', 10)
        print(f'MAX_BATCHES: {stop_early_at}')

        gmail_ids = self.imap_client.get_all_mail_uids()
        all_mails = self.get_mails(gmail_ids, stop_early_at)

        # TODO: create better way to do this
        print(f'PROGRESS: Merging duplicate items')
        all_accounts = get_unique_accounts(all_mails)

        # Create all email and account items
        print(f'PROGRESS: Creating items')
        for item in all_mails + all_accounts: pod_client.create(item)

        # Create all edges from emails to accounts/messageThreads
        print(f'PROGRESS: Creating edges')
        for email_item in all_mails: pod_client.create_edges(email_item.get_all_edges())
        print(f"Finished running {self}")