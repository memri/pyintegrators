# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/indexers.NoteListIndexer.util.ipynb (unless otherwise specified).

__all__ = ['remove_html', 'remove_prefix_chars', 'is_newline', 'is_newline_par', 'is_newline', 'is_title',
           'trim_till_newline', 'contains', 'load_spacy_model', 'HTML_LINEBREAK_REGEX']

# Cell
import re, bs4, spacy

# Cell
HTML_LINEBREAK_REGEX = "<br[^<]*/>"

def remove_html(str_):
    return re.sub('<[^<]+?>', '', str_)

def remove_prefix_chars(s, chars):
    while s[0] in chars: s = s[1:]
    return s

def is_newline(str_):
    res = re.search(HTML_LINEBREAK_REGEX, str_, re.IGNORECASE)
    if res is None: return False
    if res.group() == str_: return True
    else: return False

def is_newline_par(par):
    c = par.contents
    if is_newline(par): return True
    elif len(c) == 0: return False
    elif len(c) == 1 and is_newline(str(c[0])): return True
    else: return False

def is_newline(p):
    return str(p) == "<p></p>"

def is_title(par):
    p = "read"
    title_regex = f"(?<!<li>){p}|(?<!<li>)buy"

    match = re.search(title_regex, str(par), re.IGNORECASE)
    if match is None: return False

    cleaned_div = remove_html(str(par))
    cleaned_title = remove_html(match.group()) if match is not None else None

    # the title should be the bulk of the div
    if len(cleaned_title) > len(cleaned_div) - 2:
        return True
    else:
        return False

def trim_till_newline(pars):
    end_idx = 0
    for i, par in enumerate(pars):
        end_idx = i
        if i == len(pars)-1:
            break
        if is_newline_par(par):
            break
    return pars[:end_idx]

# def find_till_double_br(divs):
#     end_idx = 0
#     for i, s in enumerate(divs):
#         end_idx = i
#         if i == len(divs)-1:
#             break
#         if is_newline(str(divs[i])) and is_newline(str(divs[i+1])):
# #             print("FOUND ", successors[:i])
#             break
#     return divs[:end_idx]

# def get_children(elem):
#     """Fetches children of an element, put combines children when they are style element like <strong>example</strong>"""
#     res = []
#     inc_str = ""

#     for c in elem.children:
#         c = str(c)
#         inc_str += c

#         if not(c.startswith("<strong>") | c.startswith("<em>") | c.startswith("<u>")):
#             res.append(inc_str)
#             inc_str = ""
#     return res

def contains(str_, pat):
    '''case insensitive match'''
    return re.search(pat, str_, re.IGNORECASE) is not None

def load_spacy_model(m):
    try:
        nlp = spacy.load(m)
    except OSError:
        print("Downloading language model for spaCy, this will only happen once")
        from spacy.cli import download
        download(m)
        nlp = spacy.load(m)
    return nlp