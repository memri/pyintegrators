#
#  WARNING: THIS FILE IS AUTOGENERATED; DO NOT CHANGE.
#  Visit https://gitlab.memri.io/memri/schema to learn more.
#
#  schema.py
#
#  Copyright Â© 2020 memri. All rights reserved.
#

from .itembase import ItemBase, Edge


def get_constructor(_type, indexer_class=None):
    import integrators.indexers as models
    from integrators.indexers.indexer import IndexerBase
    import integrators.integrator_registry

    if _type == "Indexer" and indexer_class is not None and hasattr(integrators.integrator_registry, indexer_class):
        return getattr(integrators.integrator_registry, indexer_class)

    classes = z = {**globals(), **locals()}
    if _type in classes:
        if _type == "Indexer":
            constructor = classes[indexer_class]
        else:
            i_class = "I" + "_type"
            if i_class in classes:
                constructor = classes[i_class]
            else:
                constructor = classes[_type]
    else:
        raise TypeError
    return constructor


# Item is the baseclass for all of the data classes.
class Item(ItemBase):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None):
        super().__init__(uid)
        self.dateAccessed = dateAccessed
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.deleted = deleted
        self.externalId = externalId
        self.itemDescription = itemDescription
        self.starred = starred
        self.version = version
        self.importJson = importJson
        self.changelog = changelog if changelog is not None else []
        self.label = label if label is not None else []
        self.genericAttribute = genericAttribute if genericAttribute is not None else []
        self.measure = measure if measure is not None else []
        self.sharedWith = sharedWith if sharedWith is not None else []


# An account or subscription, for instance for some online service, or a bank account or wallet.
class Account(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 handle=None, displayName=None, service=None, itemType=None, avatarUrl=None, changelog=None,
                 label=None, genericAttribute=None, measure=None, sharedWith=None, belongsTo=None, price=None,
                 location=None, organization=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.handle = handle
        self.displayName = displayName
        self.service = service
        self.itemType = itemType
        self.avatarUrl = avatarUrl
        self.belongsTo = belongsTo if belongsTo is not None else []
        self.price = price if price is not None else []
        self.location = location if location is not None else []
        self.organization = organization if organization is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        handle = json.get("handle", None)
        displayName = json.get("displayName", None)
        service = json.get("service", None)
        itemType = json.get("itemType", None)
        avatarUrl = json.get("avatarUrl", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        belongsTo = []
        price = []
        location = []
        organization = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "belongsTo" or edge._type == "~belongsTo": 
                    belongsTo.append(edge)
                elif edge._type == "price" or edge._type == "~price": 
                    price.append(edge)
                elif edge._type == "location" or edge._type == "~location": 
                    location.append(edge)
                elif edge._type == "organization" or edge._type == "~organization": 
                    organization.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, handle=handle, displayName=displayName,
                  service=service, itemType=itemType, avatarUrl=avatarUrl, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, belongsTo=belongsTo,
                  price=price, location=location, organization=organization)
        for e in res.get_all_edges(): e.source = res
        return res


# A postal address.
class Address(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 latitude=None, longitude=None, city=None, postalCode=None, state=None, street=None, itemType=None,
                 locationAutoLookupHash=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, country=None, location=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.latitude = latitude
        self.longitude = longitude
        self.city = city
        self.postalCode = postalCode
        self.state = state
        self.street = street
        self.itemType = itemType
        self.locationAutoLookupHash = locationAutoLookupHash
        self.country = country if country is not None else []
        self.location = location if location is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        latitude = json.get("latitude", None)
        longitude = json.get("longitude", None)
        city = json.get("city", None)
        postalCode = json.get("postalCode", None)
        state = json.get("state", None)
        street = json.get("street", None)
        itemType = json.get("itemType", None)
        locationAutoLookupHash = json.get("locationAutoLookupHash", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        country = []
        location = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "country" or edge._type == "~country": 
                    country.append(edge)
                elif edge._type == "location" or edge._type == "~location": 
                    location.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, latitude=latitude, longitude=longitude, city=city,
                  postalCode=postalCode, state=state, street=street, itemType=itemType,
                  locationAutoLookupHash=locationAutoLookupHash, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, country=country,
                  location=location)
        for e in res.get_all_edges(): e.source = res
        return res


# An article, for instance from a journal, magazine or newspaper.
class Article(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, audio=None, citation=None, contentLocation=None, locationCreated=None, video=None,
                 writtenBy=None, file=None, recordedAt=None, review=None, comment=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []
        self.comment = comment if comment is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        comment = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
                elif edge._type == "comment" or edge._type == "~comment": 
                    comment.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, audio=audio,
                  citation=citation, contentLocation=contentLocation, locationCreated=locationCreated, video=video,
                  writtenBy=writtenBy, file=file, recordedAt=recordedAt, review=review, comment=comment)
        for e in res.get_all_edges(): e.source = res
        return res


# An audio file.
class Audio(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 bitrate=None, duration=None, endTime=None, fileLocation=None, startTime=None, caption=None,
                 transcript=None, changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None,
                 file=None, includes=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.bitrate = bitrate
        self.duration = duration
        self.endTime = endTime
        self.fileLocation = fileLocation
        self.startTime = startTime
        self.caption = caption
        self.transcript = transcript
        self.file = file if file is not None else []
        self.includes = includes if includes is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        bitrate = json.get("bitrate", None)
        duration = json.get("duration", None)
        endTime = json.get("endTime", None)
        fileLocation = json.get("fileLocation", None)
        startTime = json.get("startTime", None)
        caption = json.get("caption", None)
        transcript = json.get("transcript", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        file = []
        includes = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "includes" or edge._type == "~includes": 
                    includes.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, bitrate=bitrate, duration=duration,
                  endTime=endTime, fileLocation=fileLocation, startTime=startTime, caption=caption,
                  transcript=transcript, changelog=changelog, label=label, genericAttribute=genericAttribute,
                  measure=measure, sharedWith=sharedWith, file=file, includes=includes)
        for e in res.get_all_edges(): e.source = res
        return res


# TBD
class AuditItem(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 date=None, content=None, action=None, changelog=None, label=None, genericAttribute=None,
                 measure=None, sharedWith=None, appliesTo=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.date = date
        self.content = content
        self.action = action
        self.appliesTo = appliesTo if appliesTo is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        date = json.get("date", None)
        content = json.get("content", None)
        action = json.get("action", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        appliesTo = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "appliesTo" or edge._type == "~appliesTo": 
                    appliesTo.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, date=date, content=content, action=action,
                  changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith, appliesTo=appliesTo)
        for e in res.get_all_edges(): e.source = res
        return res


# TBD
class CVUStoredDefinition(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 definition=None, domain=None, name=None, query=None, selector=None, itemType=None, changelog=None,
                 label=None, genericAttribute=None, measure=None, sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.definition = definition
        self.domain = domain
        self.name = name
        self.query = query
        self.selector = selector
        self.itemType = itemType

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        definition = json.get("definition", None)
        domain = json.get("domain", None)
        name = json.get("name", None)
        query = json.get("query", None)
        selector = json.get("selector", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, definition=definition, domain=domain, name=name,
                  query=query, selector=selector, itemType=itemType, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# A comment.
class Comment(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, audio=None, citation=None, contentLocation=None, locationCreated=None, video=None,
                 writtenBy=None, file=None, recordedAt=None, review=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, audio=audio,
                  citation=citation, contentLocation=contentLocation, locationCreated=locationCreated, video=video,
                  writtenBy=writtenBy, file=file, recordedAt=recordedAt, review=review)
        for e in res.get_all_edges(): e.source = res
        return res


# A country.
class Country(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 latitude=None, longitude=None, name=None, changelog=None, label=None, genericAttribute=None,
                 measure=None, sharedWith=None, flag=None, location=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.latitude = latitude
        self.longitude = longitude
        self.name = name
        self.flag = flag if flag is not None else []
        self.location = location if location is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        latitude = json.get("latitude", None)
        longitude = json.get("longitude", None)
        name = json.get("name", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        flag = []
        location = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "flag" or edge._type == "~flag": 
                    flag.append(edge)
                elif edge._type == "location" or edge._type == "~location": 
                    location.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, latitude=latitude, longitude=longitude, name=name,
                  changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith, flag=flag, location=location)
        for e in res.get_all_edges(): e.source = res
        return res


# The most generic kind of creative work, including books, movies, photographs, software programs,
# etc.
class CreativeWork(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, audio=None, citation=None, contentLocation=None, locationCreated=None, video=None,
                 writtenBy=None, file=None, recordedAt=None, review=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, audio=audio,
                  citation=citation, contentLocation=contentLocation, locationCreated=locationCreated, video=video,
                  writtenBy=writtenBy, file=file, recordedAt=recordedAt, review=review)
        for e in res.get_all_edges(): e.source = res
        return res


# A key used in an cryptography protocol.
class CryptoKey(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 itemType=None, role=None, key=None, active=None, name=None, changelog=None, label=None,
                 genericAttribute=None, measure=None, sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.itemType = itemType
        self.role = role
        self.key = key
        self.active = active
        self.name = name

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        itemType = json.get("itemType", None)
        role = json.get("role", None)
        key = json.get("key", None)
        active = json.get("active", None)
        name = json.get("name", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, itemType=itemType, role=role, key=key,
                  active=active, name=name, changelog=changelog, label=label, genericAttribute=genericAttribute,
                  measure=measure, sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# A business corporation.
class Device(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 deviceID=None, make=None, manufacturer=None, model=None, name=None, dateAcquired=None,
                 dateLost=None, changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.deviceID = deviceID
        self.make = make
        self.manufacturer = manufacturer
        self.model = model
        self.name = name
        self.dateAcquired = dateAcquired
        self.dateLost = dateLost

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        deviceID = json.get("deviceID", None)
        make = json.get("make", None)
        manufacturer = json.get("manufacturer", None)
        model = json.get("model", None)
        name = json.get("name", None)
        dateAcquired = json.get("dateAcquired", None)
        dateLost = json.get("dateLost", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, deviceID=deviceID, make=make,
                  manufacturer=manufacturer, model=model, name=name, dateAcquired=dateAcquired, dateLost=dateLost,
                  changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# A strategy of regulating the intake of food to achieve or maintain a specific health-related goal.
class Diet(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, duration=None, changelog=None, label=None, genericAttribute=None,
                 measure=None, sharedWith=None, audio=None, citation=None, contentLocation=None,
                 locationCreated=None, video=None, writtenBy=None, file=None, recordedAt=None, review=None,
                 includedProduct=None, excludedProduct=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.duration = duration
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []
        self.includedProduct = includedProduct if includedProduct is not None else []
        self.excludedProduct = excludedProduct if excludedProduct is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
        duration = json.get("duration", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        includedProduct = []
        excludedProduct = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
                elif edge._type == "includedProduct" or edge._type == "~includedProduct": 
                    includedProduct.append(edge)
                elif edge._type == "excludedProduct" or edge._type == "~excludedProduct": 
                    excludedProduct.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, duration=duration, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, audio=audio,
                  citation=citation, contentLocation=contentLocation, locationCreated=locationCreated, video=video,
                  writtenBy=writtenBy, file=file, recordedAt=recordedAt, review=review,
                  includedProduct=includedProduct, excludedProduct=excludedProduct)
        for e in res.get_all_edges(): e.source = res
        return res


# A Downloader is used to download data from an external source, to be imported using an Importer.
class Downloader(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# A single email message.
class EmailMessage(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, subject=None, dateSent=None, dateReceived=None, service=None,
                 changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None, audio=None,
                 citation=None, contentLocation=None, locationCreated=None, video=None, writtenBy=None, file=None,
                 recordedAt=None, review=None, messageChannel=None, sender=None, receiver=None, cc=None, bcc=None,
                 replyTo=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.subject = subject
        self.dateSent = dateSent
        self.dateReceived = dateReceived
        self.service = service
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []
        self.messageChannel = messageChannel if messageChannel is not None else []
        self.sender = sender if sender is not None else []
        self.receiver = receiver if receiver is not None else []
        self.cc = cc if cc is not None else []
        self.bcc = bcc if bcc is not None else []
        self.replyTo = replyTo if replyTo is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
        subject = json.get("subject", None)
        dateSent = json.get("dateSent", None)
        dateReceived = json.get("dateReceived", None)
        service = json.get("service", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        messageChannel = []
        sender = []
        receiver = []
        cc = []
        bcc = []
        replyTo = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
                elif edge._type == "messageChannel" or edge._type == "~messageChannel": 
                    messageChannel.append(edge)
                elif edge._type == "sender" or edge._type == "~sender": 
                    sender.append(edge)
                elif edge._type == "receiver" or edge._type == "~receiver": 
                    receiver.append(edge)
                elif edge._type == "cc" or edge._type == "~cc": 
                    cc.append(edge)
                elif edge._type == "bcc" or edge._type == "~bcc": 
                    bcc.append(edge)
                elif edge._type == "replyTo" or edge._type == "~replyTo": 
                    replyTo.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, subject=subject, dateSent=dateSent,
                  dateReceived=dateReceived, service=service, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, audio=audio,
                  citation=citation, contentLocation=contentLocation, locationCreated=locationCreated, video=video,
                  writtenBy=writtenBy, file=file, recordedAt=recordedAt, review=review, messageChannel=messageChannel,
                  sender=sender, receiver=receiver, cc=cc, bcc=bcc, replyTo=replyTo)
        for e in res.get_all_edges(): e.source = res
        return res


# Any kind of event, for instance a music festival or a business meeting.
class Event(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 audience=None, startTime=None, endTime=None, duration=None, eventStatus=None, changelog=None,
                 label=None, genericAttribute=None, measure=None, sharedWith=None, location=None, review=None,
                 subEvent=None, capacity=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.audience = audience
        self.startTime = startTime
        self.endTime = endTime
        self.duration = duration
        self.eventStatus = eventStatus
        self.location = location if location is not None else []
        self.review = review if review is not None else []
        self.subEvent = subEvent if subEvent is not None else []
        self.capacity = capacity if capacity is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        audience = json.get("audience", None)
        startTime = json.get("startTime", None)
        endTime = json.get("endTime", None)
        duration = json.get("duration", None)
        eventStatus = json.get("eventStatus", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        location = []
        review = []
        subEvent = []
        capacity = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "location" or edge._type == "~location": 
                    location.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
                elif edge._type == "subEvent" or edge._type == "~subEvent": 
                    subEvent.append(edge)
                elif edge._type == "capacity" or edge._type == "~capacity": 
                    capacity.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, audience=audience, startTime=startTime,
                  endTime=endTime, duration=duration, eventStatus=eventStatus, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, location=location,
                  review=review, subEvent=subEvent, capacity=capacity)
        for e in res.get_all_edges(): e.source = res
        return res


# Fitness-related activity designed for a specific health-related purpose, including defined
# exercise routines as well as activity prescribed by a clinician.
class ExercisePlan(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, duration=None, repetitions=None, changelog=None, label=None,
                 genericAttribute=None, measure=None, sharedWith=None, audio=None, citation=None,
                 contentLocation=None, locationCreated=None, video=None, writtenBy=None, file=None, recordedAt=None,
                 review=None, workload=None, frequency=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.duration = duration
        self.repetitions = repetitions
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []
        self.workload = workload if workload is not None else []
        self.frequency = frequency if frequency is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
        duration = json.get("duration", None)
        repetitions = json.get("repetitions", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        workload = []
        frequency = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
                elif edge._type == "workload" or edge._type == "~workload": 
                    workload.append(edge)
                elif edge._type == "frequency" or edge._type == "~frequency": 
                    frequency.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, duration=duration, repetitions=repetitions,
                  changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith, audio=audio, citation=citation, contentLocation=contentLocation,
                  locationCreated=locationCreated, video=video, writtenBy=writtenBy, file=file, recordedAt=recordedAt,
                  review=review, workload=workload, frequency=frequency)
        for e in res.get_all_edges(): e.source = res
        return res


# Any file that can be stored on disk.
class File(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 sha256=None, nonce=None, key=None, filename=None, changelog=None, label=None, genericAttribute=None,
                 measure=None, sharedWith=None, resource=None, usedBy=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.sha256 = sha256
        self.nonce = nonce
        self.key = key
        self.filename = filename
        self.resource = resource if resource is not None else []
        self.usedBy = usedBy if usedBy is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        sha256 = json.get("sha256", None)
        nonce = json.get("nonce", None)
        key = json.get("key", None)
        filename = json.get("filename", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        resource = []
        usedBy = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "resource" or edge._type == "~resource": 
                    resource.append(edge)
                elif edge._type == "usedBy" or edge._type == "~usedBy": 
                    usedBy.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, sha256=sha256, nonce=nonce, key=key,
                  filename=filename, changelog=changelog, label=label, genericAttribute=genericAttribute,
                  measure=measure, sharedWith=sharedWith, resource=resource, usedBy=usedBy)
        for e in res.get_all_edges(): e.source = res
        return res


# The number of occurrences of a repeating event per measure of time.
class Frequency(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 occurrences=None, changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.occurrences = occurrences

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        occurrences = json.get("occurrences", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, occurrences=occurrences, changelog=changelog,
                  label=label, genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# Any kind of (video) game, typically rule-governed recreational activities.
class Game(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, audio=None, citation=None, contentLocation=None, locationCreated=None, video=None,
                 writtenBy=None, file=None, recordedAt=None, review=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, audio=audio,
                  citation=citation, contentLocation=contentLocation, locationCreated=locationCreated, video=video,
                  writtenBy=writtenBy, file=file, recordedAt=recordedAt, review=review)
        for e in res.get_all_edges(): e.source = res
        return res


# A generic attribute that can be referenced by an Item.
class GenericAttribute(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 name=None, boolValue=None, datetimeValue=None, floatValue=None, intValue=None, stringValue=None,
                 changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.name = name
        self.boolValue = boolValue
        self.datetimeValue = datetimeValue
        self.floatValue = floatValue
        self.intValue = intValue
        self.stringValue = stringValue

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        name = json.get("name", None)
        boolValue = json.get("boolValue", None)
        datetimeValue = json.get("datetimeValue", None)
        floatValue = json.get("floatValue", None)
        intValue = json.get("intValue", None)
        stringValue = json.get("stringValue", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, name=name, boolValue=boolValue,
                  datetimeValue=datetimeValue, floatValue=floatValue, intValue=intValue, stringValue=stringValue,
                  changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# Instructions that explain how to achieve a result by performing a sequence of steps.
class HowTo(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, audio=None, citation=None, contentLocation=None, locationCreated=None, video=None,
                 writtenBy=None, file=None, recordedAt=None, review=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, audio=audio,
                  citation=citation, contentLocation=contentLocation, locationCreated=locationCreated, video=video,
                  writtenBy=writtenBy, file=file, recordedAt=recordedAt, review=review)
        for e in res.get_all_edges(): e.source = res
        return res


# An Importer is used to import data from an external source to the Pod database.
class Importer(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 name=None, repository=None, dataType=None, icon=None, bundleImage=None, changelog=None, label=None,
                 genericAttribute=None, measure=None, sharedWith=None, importerRun=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.name = name
        self.repository = repository
        self.dataType = dataType
        self.icon = icon
        self.bundleImage = bundleImage
        self.importerRun = importerRun if importerRun is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        name = json.get("name", None)
        repository = json.get("repository", None)
        dataType = json.get("dataType", None)
        icon = json.get("icon", None)
        bundleImage = json.get("bundleImage", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        importerRun = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "importerRun" or edge._type == "~importerRun": 
                    importerRun.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, name=name, repository=repository,
                  dataType=dataType, icon=icon, bundleImage=bundleImage, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, importerRun=importerRun)
        for e in res.get_all_edges(): e.source = res
        return res


# A run of a certain Importer, that defines the details of the specific import.
class ImporterRun(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 name=None, repository=None, progress=None, dataType=None, username=None, password=None,
                 runStatus=None, errorMessage=None, progressMessage=None, changelog=None, label=None,
                 genericAttribute=None, measure=None, sharedWith=None, importer=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.name = name
        self.repository = repository
        self.progress = progress
        self.dataType = dataType
        self.username = username
        self.password = password
        self.runStatus = runStatus
        self.errorMessage = errorMessage
        self.progressMessage = progressMessage
        self.importer = importer if importer is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        name = json.get("name", None)
        repository = json.get("repository", None)
        progress = json.get("progress", None)
        dataType = json.get("dataType", None)
        username = json.get("username", None)
        password = json.get("password", None)
        runStatus = json.get("runStatus", None)
        errorMessage = json.get("errorMessage", None)
        progressMessage = json.get("progressMessage", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        importer = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "importer" or edge._type == "~importer": 
                    importer.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, name=name, repository=repository,
                  progress=progress, dataType=dataType, username=username, password=password, runStatus=runStatus,
                  errorMessage=errorMessage, progressMessage=progressMessage, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, importer=importer)
        for e in res.get_all_edges(): e.source = res
        return res


# An indexer enhances your personal data by inferring facts over existing data and adding those to
# the database.
class Indexer(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 name=None, repository=None, icon=None, query=None, bundleImage=None, runDestination=None,
                 indexerClass=None, changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None,
                 indexerRun=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.name = name
        self.repository = repository
        self.icon = icon
        self.query = query
        self.bundleImage = bundleImage
        self.runDestination = runDestination
        self.indexerClass = indexerClass
        self.indexerRun = indexerRun if indexerRun is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        name = json.get("name", None)
        repository = json.get("repository", None)
        icon = json.get("icon", None)
        query = json.get("query", None)
        bundleImage = json.get("bundleImage", None)
        runDestination = json.get("runDestination", None)
        indexerClass = json.get("indexerClass", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        indexerRun = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "indexerRun" or edge._type == "~indexerRun": 
                    indexerRun.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, name=name, repository=repository, icon=icon,
                  query=query, bundleImage=bundleImage, runDestination=runDestination, indexerClass=indexerClass,
                  changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith, indexerRun=indexerRun)
        for e in res.get_all_edges(): e.source = res
        return res


# A run of a certain Indexer.
class IndexerRun(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 name=None, repository=None, query=None, progress=None, targetDataType=None, runStatus=None,
                 errorMessage=None, progressMessage=None, changelog=None, label=None, genericAttribute=None,
                 measure=None, sharedWith=None, indexer=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.name = name
        self.repository = repository
        self.query = query
        self.progress = progress
        self.targetDataType = targetDataType
        self.runStatus = runStatus
        self.errorMessage = errorMessage
        self.progressMessage = progressMessage
        self.indexer = indexer if indexer is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        name = json.get("name", None)
        repository = json.get("repository", None)
        query = json.get("query", None)
        progress = json.get("progress", None)
        targetDataType = json.get("targetDataType", None)
        runStatus = json.get("runStatus", None)
        errorMessage = json.get("errorMessage", None)
        progressMessage = json.get("progressMessage", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        indexer = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "indexer" or edge._type == "~indexer": 
                    indexer.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, name=name, repository=repository, query=query,
                  progress=progress, targetDataType=targetDataType, runStatus=runStatus, errorMessage=errorMessage,
                  progressMessage=progressMessage, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, indexer=indexer)
        for e in res.get_all_edges(): e.source = res
        return res


# A sector that produces goods or related services within an economy.
class Industry(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 itemType=None, changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.itemType = itemType

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, itemType=itemType, changelog=changelog,
                  label=label, genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# An integrator operates on your database enhances your personal data by inferring facts over
# existing data and adding those to the database.
class Integrator(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 name=None, repository=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.name = name
        self.repository = repository

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        name = json.get("name", None)
        repository = json.get("repository", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, name=name, repository=repository,
                  changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# A Receipt is a confirmation of a transaction.
class Invoice(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None, file=None,
                 transaction=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.file = file if file is not None else []
        self.transaction = transaction if transaction is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        file = []
        transaction = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "transaction" or edge._type == "~transaction": 
                    transaction.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, file=file,
                  transaction=transaction)
        for e in res.get_all_edges(): e.source = res
        return res


# Attached to an Item, to mark it to be something.
class Label(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 color=None, name=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, comment=None, appliesTo=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.color = color
        self.name = name
        self.comment = comment if comment is not None else []
        self.appliesTo = appliesTo if appliesTo is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        color = json.get("color", None)
        name = json.get("name", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        comment = []
        appliesTo = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "comment" or edge._type == "~comment": 
                    comment.append(edge)
                elif edge._type == "appliesTo" or edge._type == "~appliesTo": 
                    appliesTo.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, color=color, name=name, changelog=changelog,
                  label=label, genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith,
                  comment=comment, appliesTo=appliesTo)
        for e in res.get_all_edges(): e.source = res
        return res


# A potential offer.
class Lead(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None, offer=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.offer = offer if offer is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        offer = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "offer" or edge._type == "~offer": 
                    offer.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, offer=offer)
        for e in res.get_all_edges(): e.source = res
        return res


# The location of something.
class Location(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 latitude=None, longitude=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.latitude = latitude
        self.longitude = longitude

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        latitude = json.get("latitude", None)
        longitude = json.get("longitude", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, latitude=latitude, longitude=longitude,
                  changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# A material that an Item is (partially) made from, for instance cotton, paper, steel, etc.
class Material(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 name=None, defaultQuantity=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, price=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.name = name
        self.defaultQuantity = defaultQuantity
        self.price = price if price is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        name = json.get("name", None)
        defaultQuantity = json.get("defaultQuantity", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        price = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "price" or edge._type == "~price": 
                    price.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, name=name, defaultQuantity=defaultQuantity,
                  changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith, price=price)
        for e in res.get_all_edges(): e.source = res
        return res


# A measure consists of a definition, symbol, unit and value (int, float, string, bool, or
# datetime).
class Measure(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 definition=None, symbol=None, intValue=None, floatValue=None, stringValue=None, datetimeValue=None,
                 boolValue=None, changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None,
                 unit=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.definition = definition
        self.symbol = symbol
        self.intValue = intValue
        self.floatValue = floatValue
        self.stringValue = stringValue
        self.datetimeValue = datetimeValue
        self.boolValue = boolValue
        self.unit = unit if unit is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        definition = json.get("definition", None)
        symbol = json.get("symbol", None)
        intValue = json.get("intValue", None)
        floatValue = json.get("floatValue", None)
        stringValue = json.get("stringValue", None)
        datetimeValue = json.get("datetimeValue", None)
        boolValue = json.get("boolValue", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        unit = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "unit" or edge._type == "~unit": 
                    unit.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, definition=definition, symbol=symbol,
                  intValue=intValue, floatValue=floatValue, stringValue=stringValue, datetimeValue=datetimeValue,
                  boolValue=boolValue, changelog=changelog, label=label, genericAttribute=genericAttribute,
                  measure=measure, sharedWith=sharedWith, unit=unit)
        for e in res.get_all_edges(): e.source = res
        return res


# A media object, such as an image, video, or audio object embedded in a web page or a downloadable
# dataset i.e. DataDownload. Note that a creative work may have many media objects associated with it
# on the same web page. For example, a page about a single song (MusicRecording) may have a music
# video (VideoObject), and a high and low bandwidth audio stream (2 AudioObject's).
class MediaObject(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 bitrate=None, duration=None, endTime=None, fileLocation=None, startTime=None, changelog=None,
                 label=None, genericAttribute=None, measure=None, sharedWith=None, file=None, includes=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.bitrate = bitrate
        self.duration = duration
        self.endTime = endTime
        self.fileLocation = fileLocation
        self.startTime = startTime
        self.file = file if file is not None else []
        self.includes = includes if includes is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        bitrate = json.get("bitrate", None)
        duration = json.get("duration", None)
        endTime = json.get("endTime", None)
        fileLocation = json.get("fileLocation", None)
        startTime = json.get("startTime", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        file = []
        includes = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "includes" or edge._type == "~includes": 
                    includes.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, bitrate=bitrate, duration=duration,
                  endTime=endTime, fileLocation=fileLocation, startTime=startTime, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, file=file,
                  includes=includes)
        for e in res.get_all_edges(): e.source = res
        return res


# Any condition of the human body that affects the normal functioning of a person, whether
# physically or mentally. Includes diseases, injuries, disabilities, disorders, syndromes, etc.
class MedicalCondition(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 itemType=None, name=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.itemType = itemType
        self.name = name

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        itemType = json.get("itemType", None)
        name = json.get("name", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, itemType=itemType, name=name, changelog=changelog,
                  label=label, genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# A single message.
class Message(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, subject=None, dateSent=None, dateReceived=None, service=None,
                 changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None, audio=None,
                 citation=None, contentLocation=None, locationCreated=None, video=None, writtenBy=None, file=None,
                 recordedAt=None, review=None, messageChannel=None, sender=None, receiver=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.subject = subject
        self.dateSent = dateSent
        self.dateReceived = dateReceived
        self.service = service
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []
        self.messageChannel = messageChannel if messageChannel is not None else []
        self.sender = sender if sender is not None else []
        self.receiver = receiver if receiver is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
        subject = json.get("subject", None)
        dateSent = json.get("dateSent", None)
        dateReceived = json.get("dateReceived", None)
        service = json.get("service", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        messageChannel = []
        sender = []
        receiver = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
                elif edge._type == "messageChannel" or edge._type == "~messageChannel": 
                    messageChannel.append(edge)
                elif edge._type == "sender" or edge._type == "~sender": 
                    sender.append(edge)
                elif edge._type == "receiver" or edge._type == "~receiver": 
                    receiver.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, subject=subject, dateSent=dateSent,
                  dateReceived=dateReceived, service=service, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, audio=audio,
                  citation=citation, contentLocation=contentLocation, locationCreated=locationCreated, video=video,
                  writtenBy=writtenBy, file=file, recordedAt=recordedAt, review=review, messageChannel=messageChannel,
                  sender=sender, receiver=receiver)
        for e in res.get_all_edges(): e.source = res
        return res


# A chat is a collection of messages.
class MessageChannel(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 name=None, topic=None, encrypted=None, changelog=None, label=None, genericAttribute=None,
                 measure=None, sharedWith=None, photo=None, receiver=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.name = name
        self.topic = topic
        self.encrypted = encrypted
        self.photo = photo if photo is not None else []
        self.receiver = receiver if receiver is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        name = json.get("name", None)
        topic = json.get("topic", None)
        encrypted = json.get("encrypted", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        photo = []
        receiver = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "photo" or edge._type == "~photo": 
                    photo.append(edge)
                elif edge._type == "receiver" or edge._type == "~receiver": 
                    receiver.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, name=name, topic=topic, encrypted=encrypted,
                  changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith, photo=photo, receiver=receiver)
        for e in res.get_all_edges(): e.source = res
        return res


# A way of transportation, for instance a bus or airplane.
class ModeOfTransport(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# Any type of video, for instance a movie, TV show, animation etc.
class MovingImage(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, audio=None, citation=None, contentLocation=None, locationCreated=None, video=None,
                 writtenBy=None, file=None, recordedAt=None, review=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, audio=audio,
                  citation=citation, contentLocation=contentLocation, locationCreated=locationCreated, video=video,
                  writtenBy=writtenBy, file=file, recordedAt=recordedAt, review=review)
        for e in res.get_all_edges(): e.source = res
        return res


# TBD
class NavigationItem(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, sessionName=None, sequence=None, itemType=None, changelog=None, label=None,
                 genericAttribute=None, measure=None, sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.sessionName = sessionName
        self.sequence = sequence
        self.itemType = itemType

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        sessionName = json.get("sessionName", None)
        sequence = json.get("sequence", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, sessionName=sessionName,
                  sequence=sequence, itemType=itemType, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# A group or system of interconnected people or things, for instance a social network.
class Network(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 name=None, changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None,
                 organization=None, resource=None, website=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.name = name
        self.organization = organization if organization is not None else []
        self.resource = resource if resource is not None else []
        self.website = website if website is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        name = json.get("name", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        organization = []
        resource = []
        website = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "organization" or edge._type == "~organization": 
                    organization.append(edge)
                elif edge._type == "resource" or edge._type == "~resource": 
                    resource.append(edge)
                elif edge._type == "website" or edge._type == "~website": 
                    website.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, name=name, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith,
                  organization=organization, resource=resource, website=website)
        for e in res.get_all_edges(): e.source = res
        return res


# A file containing a note.
class Note(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, audio=None, citation=None, contentLocation=None, locationCreated=None, video=None,
                 writtenBy=None, file=None, recordedAt=None, review=None, comment=None, noteList=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []
        self.comment = comment if comment is not None else []
        self.noteList = noteList if noteList is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        comment = []
        noteList = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
                elif edge._type == "comment" or edge._type == "~comment": 
                    comment.append(edge)
                elif edge._type == "noteList" or edge._type == "~noteList": 
                    noteList.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, audio=audio,
                  citation=citation, contentLocation=contentLocation, locationCreated=locationCreated, video=video,
                  writtenBy=writtenBy, file=file, recordedAt=recordedAt, review=review, comment=comment,
                  noteList=noteList)
        for e in res.get_all_edges(): e.source = res
        return res


# A list in a note.
class NoteList(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, category=None, changelog=None, label=None, genericAttribute=None,
                 measure=None, sharedWith=None, audio=None, citation=None, contentLocation=None,
                 locationCreated=None, video=None, writtenBy=None, file=None, recordedAt=None, review=None,
                 span=None, itemSpan=None, note=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.category = category
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []
        self.span = span if span is not None else []
        self.itemSpan = itemSpan if itemSpan is not None else []
        self.note = note if note is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
        category = json.get("category", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        span = []
        itemSpan = []
        note = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
                elif edge._type == "span" or edge._type == "~span": 
                    span.append(edge)
                elif edge._type == "itemSpan" or edge._type == "~itemSpan": 
                    itemSpan.append(edge)
                elif edge._type == "note" or edge._type == "~note": 
                    note.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, category=category, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, audio=audio,
                  citation=citation, contentLocation=contentLocation, locationCreated=locationCreated, video=video,
                  writtenBy=writtenBy, file=file, recordedAt=recordedAt, review=review, span=span, itemSpan=itemSpan,
                  note=note)
        for e in res.get_all_edges(): e.source = res
        return res


# An offer for some transaction, for instance to buy something or to get some service.
class Offer(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None, transaction=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.transaction = transaction if transaction is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        transaction = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "transaction" or edge._type == "~transaction": 
                    transaction.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, transaction=transaction)
        for e in res.get_all_edges(): e.source = res
        return res


# Hours that an organization is open.
class OpeningHours(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None, timeFrame=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.timeFrame = timeFrame if timeFrame is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        timeFrame = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "timeFrame" or edge._type == "~timeFrame": 
                    timeFrame.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, timeFrame=timeFrame)
        for e in res.get_all_edges(): e.source = res
        return res


# An option for some choice, for instance a Vote.
class Option(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# An organization, for instance an NGO, company or school.
class Organization(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 name=None, dateFounded=None, areaServed=None, taxId=None, changelog=None, label=None,
                 genericAttribute=None, measure=None, sharedWith=None, address=None, foundingLocation=None,
                 logo=None, review=None, subOrganization=None, performsAt=None, attends=None, organizes=None,
                 openingHours=None, industry=None, buyer=None, seller=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.name = name
        self.dateFounded = dateFounded
        self.areaServed = areaServed
        self.taxId = taxId
        self.address = address if address is not None else []
        self.foundingLocation = foundingLocation if foundingLocation is not None else []
        self.logo = logo if logo is not None else []
        self.review = review if review is not None else []
        self.subOrganization = subOrganization if subOrganization is not None else []
        self.performsAt = performsAt if performsAt is not None else []
        self.attends = attends if attends is not None else []
        self.organizes = organizes if organizes is not None else []
        self.openingHours = openingHours if openingHours is not None else []
        self.industry = industry if industry is not None else []
        self.buyer = buyer if buyer is not None else []
        self.seller = seller if seller is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        name = json.get("name", None)
        dateFounded = json.get("dateFounded", None)
        areaServed = json.get("areaServed", None)
        taxId = json.get("taxId", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        address = []
        foundingLocation = []
        logo = []
        review = []
        subOrganization = []
        performsAt = []
        attends = []
        organizes = []
        openingHours = []
        industry = []
        buyer = []
        seller = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "address" or edge._type == "~address": 
                    address.append(edge)
                elif edge._type == "foundingLocation" or edge._type == "~foundingLocation": 
                    foundingLocation.append(edge)
                elif edge._type == "logo" or edge._type == "~logo": 
                    logo.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
                elif edge._type == "subOrganization" or edge._type == "~subOrganization": 
                    subOrganization.append(edge)
                elif edge._type == "performsAt" or edge._type == "~performsAt": 
                    performsAt.append(edge)
                elif edge._type == "attends" or edge._type == "~attends": 
                    attends.append(edge)
                elif edge._type == "organizes" or edge._type == "~organizes": 
                    organizes.append(edge)
                elif edge._type == "openingHours" or edge._type == "~openingHours": 
                    openingHours.append(edge)
                elif edge._type == "industry" or edge._type == "~industry": 
                    industry.append(edge)
                elif edge._type == "buyer" or edge._type == "~buyer": 
                    buyer.append(edge)
                elif edge._type == "seller" or edge._type == "~seller": 
                    seller.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, name=name, dateFounded=dateFounded,
                  areaServed=areaServed, taxId=taxId, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, address=address,
                  foundingLocation=foundingLocation, logo=logo, review=review, subOrganization=subOrganization,
                  performsAt=performsAt, attends=attends, organizes=organizes, openingHours=openingHours,
                  industry=industry, buyer=buyer, seller=seller)
        for e in res.get_all_edges(): e.source = res
        return res


# A work of performing art, for instance dance, theater, opera or musical.
class PerformingArt(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, audio=None, citation=None, contentLocation=None, locationCreated=None, video=None,
                 writtenBy=None, file=None, recordedAt=None, review=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, audio=audio,
                  citation=citation, contentLocation=contentLocation, locationCreated=locationCreated, video=video,
                  writtenBy=writtenBy, file=file, recordedAt=recordedAt, review=review)
        for e in res.get_all_edges(): e.source = res
        return res


# A person (alive, dead, undead, or fictional).
class Person(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 birthDate=None, email=None, deathDate=None, firstName=None, lastName=None, gender=None,
                 sexualOrientation=None, displayName=None, role=None, changelog=None, label=None,
                 genericAttribute=None, measure=None, sharedWith=None, occurence=None, address=None, birthPlace=None,
                 deathPlace=None, profilePicture=None, relationship=None, hasPhoneNumber=None, website=None,
                 industry=None, cryptoKey=None, account=None, diet=None, medicalCondition=None, memberOf=None,
                 performsAt=None, attends=None, organizes=None, founded=None, buyer=None, seller=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.birthDate = birthDate
        self.email = email
        self.deathDate = deathDate
        self.firstName = firstName
        self.lastName = lastName
        self.gender = gender
        self.sexualOrientation = sexualOrientation
        self.displayName = displayName
        self.role = role
        self.occurence = occurence if occurence is not None else []
        self.address = address if address is not None else []
        self.birthPlace = birthPlace if birthPlace is not None else []
        self.deathPlace = deathPlace if deathPlace is not None else []
        self.profilePicture = profilePicture if profilePicture is not None else []
        self.relationship = relationship if relationship is not None else []
        self.hasPhoneNumber = hasPhoneNumber if hasPhoneNumber is not None else []
        self.website = website if website is not None else []
        self.industry = industry if industry is not None else []
        self.cryptoKey = cryptoKey if cryptoKey is not None else []
        self.account = account if account is not None else []
        self.diet = diet if diet is not None else []
        self.medicalCondition = medicalCondition if medicalCondition is not None else []
        self.memberOf = memberOf if memberOf is not None else []
        self.performsAt = performsAt if performsAt is not None else []
        self.attends = attends if attends is not None else []
        self.organizes = organizes if organizes is not None else []
        self.founded = founded if founded is not None else []
        self.buyer = buyer if buyer is not None else []
        self.seller = seller if seller is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        birthDate = json.get("birthDate", None)
        email = json.get("email", None)
        deathDate = json.get("deathDate", None)
        firstName = json.get("firstName", None)
        lastName = json.get("lastName", None)
        gender = json.get("gender", None)
        sexualOrientation = json.get("sexualOrientation", None)
        displayName = json.get("displayName", None)
        role = json.get("role", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        occurence = []
        address = []
        birthPlace = []
        deathPlace = []
        profilePicture = []
        relationship = []
        hasPhoneNumber = []
        website = []
        industry = []
        cryptoKey = []
        account = []
        diet = []
        medicalCondition = []
        memberOf = []
        performsAt = []
        attends = []
        organizes = []
        founded = []
        buyer = []
        seller = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "occurence" or edge._type == "~occurence": 
                    occurence.append(edge)
                elif edge._type == "address" or edge._type == "~address": 
                    address.append(edge)
                elif edge._type == "birthPlace" or edge._type == "~birthPlace": 
                    birthPlace.append(edge)
                elif edge._type == "deathPlace" or edge._type == "~deathPlace": 
                    deathPlace.append(edge)
                elif edge._type == "profilePicture" or edge._type == "~profilePicture": 
                    profilePicture.append(edge)
                elif edge._type == "relationship" or edge._type == "~relationship": 
                    relationship.append(edge)
                elif edge._type == "hasPhoneNumber" or edge._type == "~hasPhoneNumber": 
                    hasPhoneNumber.append(edge)
                elif edge._type == "website" or edge._type == "~website": 
                    website.append(edge)
                elif edge._type == "industry" or edge._type == "~industry": 
                    industry.append(edge)
                elif edge._type == "cryptoKey" or edge._type == "~cryptoKey": 
                    cryptoKey.append(edge)
                elif edge._type == "account" or edge._type == "~account": 
                    account.append(edge)
                elif edge._type == "diet" or edge._type == "~diet": 
                    diet.append(edge)
                elif edge._type == "medicalCondition" or edge._type == "~medicalCondition": 
                    medicalCondition.append(edge)
                elif edge._type == "memberOf" or edge._type == "~memberOf": 
                    memberOf.append(edge)
                elif edge._type == "performsAt" or edge._type == "~performsAt": 
                    performsAt.append(edge)
                elif edge._type == "attends" or edge._type == "~attends": 
                    attends.append(edge)
                elif edge._type == "organizes" or edge._type == "~organizes": 
                    organizes.append(edge)
                elif edge._type == "founded" or edge._type == "~founded": 
                    founded.append(edge)
                elif edge._type == "buyer" or edge._type == "~buyer": 
                    buyer.append(edge)
                elif edge._type == "seller" or edge._type == "~seller": 
                    seller.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, birthDate=birthDate, email=email,
                  deathDate=deathDate, firstName=firstName, lastName=lastName, gender=gender,
                  sexualOrientation=sexualOrientation, displayName=displayName, role=role, changelog=changelog,
                  label=label, genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith,
                  occurence=occurence, address=address, birthPlace=birthPlace, deathPlace=deathPlace,
                  profilePicture=profilePicture, relationship=relationship, hasPhoneNumber=hasPhoneNumber,
                  website=website, industry=industry, cryptoKey=cryptoKey, account=account, diet=diet,
                  medicalCondition=medicalCondition, memberOf=memberOf, performsAt=performsAt, attends=attends,
                  organizes=organizes, founded=founded, buyer=buyer, seller=seller)
        for e in res.get_all_edges(): e.source = res
        return res


# A telephone number.
class PhoneNumber(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 phoneNumber=None, itemType=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.phoneNumber = phoneNumber
        self.itemType = itemType

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        phoneNumber = json.get("phoneNumber", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, phoneNumber=phoneNumber, itemType=itemType,
                  changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# An image file.
class Photo(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 bitrate=None, duration=None, endTime=None, fileLocation=None, startTime=None, caption=None,
                 exifData=None, name=None, height=None, width=None, channels=None, changelog=None, label=None,
                 genericAttribute=None, measure=None, sharedWith=None, file=None, includes=None, thumbnail=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.bitrate = bitrate
        self.duration = duration
        self.endTime = endTime
        self.fileLocation = fileLocation
        self.startTime = startTime
        self.caption = caption
        self.exifData = exifData
        self.name = name
        self.height = height
        self.width = width
        self.channels = channels
        self.file = file if file is not None else []
        self.includes = includes if includes is not None else []
        self.thumbnail = thumbnail if thumbnail is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        bitrate = json.get("bitrate", None)
        duration = json.get("duration", None)
        endTime = json.get("endTime", None)
        fileLocation = json.get("fileLocation", None)
        startTime = json.get("startTime", None)
        caption = json.get("caption", None)
        exifData = json.get("exifData", None)
        name = json.get("name", None)
        height = json.get("height", None)
        width = json.get("width", None)
        channels = json.get("channels", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        file = []
        includes = []
        thumbnail = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "includes" or edge._type == "~includes": 
                    includes.append(edge)
                elif edge._type == "thumbnail" or edge._type == "~thumbnail": 
                    thumbnail.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, bitrate=bitrate, duration=duration,
                  endTime=endTime, fileLocation=fileLocation, startTime=startTime, caption=caption, exifData=exifData,
                  name=name, height=height, width=width, channels=channels, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, file=file,
                  includes=includes, thumbnail=thumbnail)
        for e in res.get_all_edges(): e.source = res
        return res


# Some object that exists in the real world.
class PhysicalEntity(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None, belongsTo=None,
                 instanceOf=None, location=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.belongsTo = belongsTo if belongsTo is not None else []
        self.instanceOf = instanceOf if instanceOf is not None else []
        self.location = location if location is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        belongsTo = []
        instanceOf = []
        location = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "belongsTo" or edge._type == "~belongsTo": 
                    belongsTo.append(edge)
                elif edge._type == "instanceOf" or edge._type == "~instanceOf": 
                    instanceOf.append(edge)
                elif edge._type == "location" or edge._type == "~location": 
                    location.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, belongsTo=belongsTo,
                  instanceOf=instanceOf, location=location)
        for e in res.get_all_edges(): e.source = res
        return res


# Any product.
class Product(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 audience=None, color=None, manufacturer=None, model=None, pattern=None, dateAcquired=None,
                 productCondition=None, dateProduced=None, datePublished=None, service=None, changelog=None,
                 label=None, genericAttribute=None, measure=None, sharedWith=None, material=None, productCode=None,
                 review=None, accessoryOrSparePartFor=None, consumableBy=None, price=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.audience = audience
        self.color = color
        self.manufacturer = manufacturer
        self.model = model
        self.pattern = pattern
        self.dateAcquired = dateAcquired
        self.productCondition = productCondition
        self.dateProduced = dateProduced
        self.datePublished = datePublished
        self.service = service
        self.material = material if material is not None else []
        self.productCode = productCode if productCode is not None else []
        self.review = review if review is not None else []
        self.accessoryOrSparePartFor = accessoryOrSparePartFor if accessoryOrSparePartFor is not None else []
        self.consumableBy = consumableBy if consumableBy is not None else []
        self.price = price if price is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        audience = json.get("audience", None)
        color = json.get("color", None)
        manufacturer = json.get("manufacturer", None)
        model = json.get("model", None)
        pattern = json.get("pattern", None)
        dateAcquired = json.get("dateAcquired", None)
        productCondition = json.get("productCondition", None)
        dateProduced = json.get("dateProduced", None)
        datePublished = json.get("datePublished", None)
        service = json.get("service", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        material = []
        productCode = []
        review = []
        accessoryOrSparePartFor = []
        consumableBy = []
        price = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "material" or edge._type == "~material": 
                    material.append(edge)
                elif edge._type == "productCode" or edge._type == "~productCode": 
                    productCode.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
                elif edge._type == "accessoryOrSparePartFor" or edge._type == "~accessoryOrSparePartFor": 
                    accessoryOrSparePartFor.append(edge)
                elif edge._type == "consumableBy" or edge._type == "~consumableBy": 
                    consumableBy.append(edge)
                elif edge._type == "price" or edge._type == "~price": 
                    price.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, audience=audience, color=color,
                  manufacturer=manufacturer, model=model, pattern=pattern, dateAcquired=dateAcquired,
                  productCondition=productCondition, dateProduced=dateProduced, datePublished=datePublished,
                  service=service, changelog=changelog, label=label, genericAttribute=genericAttribute,
                  measure=measure, sharedWith=sharedWith, material=material, productCode=productCode, review=review,
                  accessoryOrSparePartFor=accessoryOrSparePartFor, consumableBy=consumableBy, price=price)
        for e in res.get_all_edges(): e.source = res
        return res


# A code or number used to identify Products, for instance a UPC or GTIN.
class ProductCode(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 productCodeType=None, productNumber=None, changelog=None, label=None, genericAttribute=None,
                 measure=None, sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.productCodeType = productCodeType
        self.productNumber = productNumber

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        productCodeType = json.get("productCodeType", None)
        productNumber = json.get("productNumber", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, productCodeType=productCodeType,
                  productNumber=productNumber, changelog=changelog, label=label, genericAttribute=genericAttribute,
                  measure=measure, sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# A bill that describes money owed for some Transaction.
class Receipt(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 dateDue=None, changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None,
                 file=None, transaction=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.dateDue = dateDue
        self.file = file if file is not None else []
        self.transaction = transaction if transaction is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        dateDue = json.get("dateDue", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        file = []
        transaction = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "transaction" or edge._type == "~transaction": 
                    transaction.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, dateDue=dateDue, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, file=file,
                  transaction=transaction)
        for e in res.get_all_edges(): e.source = res
        return res


# A set of instructions for preparing a particular dish, including a list of the ingredients
# required.
class Recipe(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, duration=None, instructions=None, changelog=None, label=None,
                 genericAttribute=None, measure=None, sharedWith=None, audio=None, citation=None,
                 contentLocation=None, locationCreated=None, video=None, writtenBy=None, file=None, recordedAt=None,
                 review=None, ingredient=None, price=None, yields=None, toolRequired=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.duration = duration
        self.instructions = instructions
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []
        self.ingredient = ingredient if ingredient is not None else []
        self.price = price if price is not None else []
        self.yields = yields if yields is not None else []
        self.toolRequired = toolRequired if toolRequired is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
        duration = json.get("duration", None)
        instructions = json.get("instructions", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        ingredient = []
        price = []
        yields = []
        toolRequired = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
                elif edge._type == "ingredient" or edge._type == "~ingredient": 
                    ingredient.append(edge)
                elif edge._type == "price" or edge._type == "~price": 
                    price.append(edge)
                elif edge._type == "yields" or edge._type == "~yields": 
                    yields.append(edge)
                elif edge._type == "toolRequired" or edge._type == "~toolRequired": 
                    toolRequired.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, duration=duration, instructions=instructions,
                  changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith, audio=audio, citation=citation, contentLocation=contentLocation,
                  locationCreated=locationCreated, video=video, writtenBy=writtenBy, file=file, recordedAt=recordedAt,
                  review=review, ingredient=ingredient, price=price, yields=yields, toolRequired=toolRequired)
        for e in res.get_all_edges(): e.source = res
        return res


# A audio performance or production. Can be a single, album, radio show, podcast etc.
class Recording(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, audio=None, citation=None, contentLocation=None, locationCreated=None, video=None,
                 writtenBy=None, file=None, recordedAt=None, review=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, audio=audio,
                  citation=citation, contentLocation=contentLocation, locationCreated=locationCreated, video=video,
                  writtenBy=writtenBy, file=file, recordedAt=recordedAt, review=review)
        for e in res.get_all_edges(): e.source = res
        return res


# Describes a reservation, for instance for a Route or Event, or at a Organization.
class Reservation(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 dateReserved=None, reservationStatus=None, changelog=None, label=None, genericAttribute=None,
                 measure=None, sharedWith=None, organization=None, route=None, reservedBy=None, reservedFor=None,
                 price=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.dateReserved = dateReserved
        self.reservationStatus = reservationStatus
        self.organization = organization if organization is not None else []
        self.route = route if route is not None else []
        self.reservedBy = reservedBy if reservedBy is not None else []
        self.reservedFor = reservedFor if reservedFor is not None else []
        self.price = price if price is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        dateReserved = json.get("dateReserved", None)
        reservationStatus = json.get("reservationStatus", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        organization = []
        route = []
        reservedBy = []
        reservedFor = []
        price = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "organization" or edge._type == "~organization": 
                    organization.append(edge)
                elif edge._type == "route" or edge._type == "~route": 
                    route.append(edge)
                elif edge._type == "reservedBy" or edge._type == "~reservedBy": 
                    reservedBy.append(edge)
                elif edge._type == "reservedFor" or edge._type == "~reservedFor": 
                    reservedFor.append(edge)
                elif edge._type == "price" or edge._type == "~price": 
                    price.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, dateReserved=dateReserved,
                  reservationStatus=reservationStatus, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith,
                  organization=organization, route=route, reservedBy=reservedBy, reservedFor=reservedFor, price=price)
        for e in res.get_all_edges(): e.source = res
        return res


# A universal resource location
class Resource(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 url=None, changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None,
                 usedBy=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.url = url
        self.usedBy = usedBy if usedBy is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        url = json.get("url", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        usedBy = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "usedBy" or edge._type == "~usedBy": 
                    usedBy.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, url=url, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, usedBy=usedBy)
        for e in res.get_all_edges(): e.source = res
        return res


# A review of an Item, for instance a Organization, CreativeWork, or Product.
class Review(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, audio=None, citation=None, contentLocation=None, locationCreated=None, video=None,
                 writtenBy=None, file=None, recordedAt=None, review=None, rating=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []
        self.rating = rating if rating is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        rating = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
                elif edge._type == "rating" or edge._type == "~rating": 
                    rating.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, audio=audio,
                  citation=citation, contentLocation=contentLocation, locationCreated=locationCreated, video=video,
                  writtenBy=writtenBy, file=file, recordedAt=recordedAt, review=review, rating=rating)
        for e in res.get_all_edges(): e.source = res
        return res


# A route from one Location to another, using some ModeOfTransport.
class Route(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 startTime=None, endTime=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, modeOfTransport=None, startLocation=None, endLocation=None, price=None,
                 receipt=None, ticket=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.startTime = startTime
        self.endTime = endTime
        self.modeOfTransport = modeOfTransport if modeOfTransport is not None else []
        self.startLocation = startLocation if startLocation is not None else []
        self.endLocation = endLocation if endLocation is not None else []
        self.price = price if price is not None else []
        self.receipt = receipt if receipt is not None else []
        self.ticket = ticket if ticket is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        startTime = json.get("startTime", None)
        endTime = json.get("endTime", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        modeOfTransport = []
        startLocation = []
        endLocation = []
        price = []
        receipt = []
        ticket = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "modeOfTransport" or edge._type == "~modeOfTransport": 
                    modeOfTransport.append(edge)
                elif edge._type == "startLocation" or edge._type == "~startLocation": 
                    startLocation.append(edge)
                elif edge._type == "endLocation" or edge._type == "~endLocation": 
                    endLocation.append(edge)
                elif edge._type == "price" or edge._type == "~price": 
                    price.append(edge)
                elif edge._type == "receipt" or edge._type == "~receipt": 
                    receipt.append(edge)
                elif edge._type == "ticket" or edge._type == "~ticket": 
                    ticket.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, startTime=startTime, endTime=endTime,
                  changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith, modeOfTransport=modeOfTransport, startLocation=startLocation,
                  endLocation=endLocation, price=price, receipt=receipt, ticket=ticket)
        for e in res.get_all_edges(): e.source = res
        return res


# A setting, named by a key, specifications in JSON format.
class Setting(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 key=None, json=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.key = key
        self.json = json

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        key = json.get("key", None)
        json = json.get("json", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, key=key, json=json, changelog=changelog,
                  label=label, genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# A class that represents a position of an element in a string.
class Span(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 startIdx=None, endIdx=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.startIdx = startIdx
        self.endIdx = endIdx

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        startIdx = json.get("startIdx", None)
        endIdx = json.get("endIdx", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, startIdx=startIdx, endIdx=endIdx,
                  changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# A specified period of time in which something occurs or is planned to take place.
class TimeFrame(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 startTime=None, endTime=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.startTime = startTime
        self.endTime = endTime

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        startTime = json.get("startTime", None)
        endTime = json.get("endTime", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, startTime=startTime, endTime=endTime,
                  changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# An agreement between a buyer and a seller to exchange an asset for payment.
class Transaction(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 orderStatus=None, orderNumber=None, discountCode=None, dateOrdered=None, dateExecuted=None,
                 changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None,
                 purchaseLocation=None, product=None, billingAddress=None, payedWithAccount=None, discount=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.orderStatus = orderStatus
        self.orderNumber = orderNumber
        self.discountCode = discountCode
        self.dateOrdered = dateOrdered
        self.dateExecuted = dateExecuted
        self.purchaseLocation = purchaseLocation if purchaseLocation is not None else []
        self.product = product if product is not None else []
        self.billingAddress = billingAddress if billingAddress is not None else []
        self.payedWithAccount = payedWithAccount if payedWithAccount is not None else []
        self.discount = discount if discount is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        orderStatus = json.get("orderStatus", None)
        orderNumber = json.get("orderNumber", None)
        discountCode = json.get("discountCode", None)
        dateOrdered = json.get("dateOrdered", None)
        dateExecuted = json.get("dateExecuted", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        purchaseLocation = []
        product = []
        billingAddress = []
        payedWithAccount = []
        discount = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "purchaseLocation" or edge._type == "~purchaseLocation": 
                    purchaseLocation.append(edge)
                elif edge._type == "product" or edge._type == "~product": 
                    product.append(edge)
                elif edge._type == "billingAddress" or edge._type == "~billingAddress": 
                    billingAddress.append(edge)
                elif edge._type == "payedWithAccount" or edge._type == "~payedWithAccount": 
                    payedWithAccount.append(edge)
                elif edge._type == "discount" or edge._type == "~discount": 
                    discount.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, orderStatus=orderStatus, orderNumber=orderNumber,
                  discountCode=discountCode, dateOrdered=dateOrdered, dateExecuted=dateExecuted, changelog=changelog,
                  label=label, genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith,
                  purchaseLocation=purchaseLocation, product=product, billingAddress=billingAddress,
                  payedWithAccount=payedWithAccount, discount=discount)
        for e in res.get_all_edges(): e.source = res
        return res


# A trip or journey, consisting of Routes.
class Trip(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 startTime=None, endTime=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, route=None, startLocation=None, endLocation=None, price=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.startTime = startTime
        self.endTime = endTime
        self.route = route if route is not None else []
        self.startLocation = startLocation if startLocation is not None else []
        self.endLocation = endLocation if endLocation is not None else []
        self.price = price if price is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        startTime = json.get("startTime", None)
        endTime = json.get("endTime", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        route = []
        startLocation = []
        endLocation = []
        price = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "route" or edge._type == "~route": 
                    route.append(edge)
                elif edge._type == "startLocation" or edge._type == "~startLocation": 
                    startLocation.append(edge)
                elif edge._type == "endLocation" or edge._type == "~endLocation": 
                    endLocation.append(edge)
                elif edge._type == "price" or edge._type == "~price": 
                    price.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, startTime=startTime, endTime=endTime,
                  changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith, route=route, startLocation=startLocation, endLocation=endLocation,
                  price=price)
        for e in res.get_all_edges(): e.source = res
        return res


# A unit, typically from International System of Units (SI).
class Unit(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 symbol=None, name=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.symbol = symbol
        self.name = name

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        symbol = json.get("symbol", None)
        name = json.get("name", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, symbol=symbol, name=name, changelog=changelog,
                  label=label, genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# A video file.
class Video(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 bitrate=None, duration=None, endTime=None, fileLocation=None, startTime=None, caption=None,
                 exifData=None, name=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, file=None, includes=None, thumbnail=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.bitrate = bitrate
        self.duration = duration
        self.endTime = endTime
        self.fileLocation = fileLocation
        self.startTime = startTime
        self.caption = caption
        self.exifData = exifData
        self.name = name
        self.file = file if file is not None else []
        self.includes = includes if includes is not None else []
        self.thumbnail = thumbnail if thumbnail is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        bitrate = json.get("bitrate", None)
        duration = json.get("duration", None)
        endTime = json.get("endTime", None)
        fileLocation = json.get("fileLocation", None)
        startTime = json.get("startTime", None)
        caption = json.get("caption", None)
        exifData = json.get("exifData", None)
        name = json.get("name", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        file = []
        includes = []
        thumbnail = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "includes" or edge._type == "~includes": 
                    includes.append(edge)
                elif edge._type == "thumbnail" or edge._type == "~thumbnail": 
                    thumbnail.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, bitrate=bitrate, duration=duration,
                  endTime=endTime, fileLocation=fileLocation, startTime=startTime, caption=caption, exifData=exifData,
                  name=name, changelog=changelog, label=label, genericAttribute=genericAttribute, measure=measure,
                  sharedWith=sharedWith, file=file, includes=includes, thumbnail=thumbnail)
        for e in res.get_all_edges(): e.source = res
        return res


# A work of visual arts, for instance a painting, sculpture or drawing.
class VisualArt(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, audio=None, citation=None, contentLocation=None, locationCreated=None, video=None,
                 writtenBy=None, file=None, recordedAt=None, review=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, audio=audio,
                  citation=citation, contentLocation=contentLocation, locationCreated=locationCreated, video=video,
                  writtenBy=writtenBy, file=file, recordedAt=recordedAt, review=review)
        for e in res.get_all_edges(): e.source = res
        return res


# An occasion where a choice is made choose between two or more options, for instance an election.
class Vote(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 itemType=None, changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None,
                 option=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.itemType = itemType
        self.option = option if option is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        option = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "option" or edge._type == "~option": 
                    option.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, itemType=itemType, changelog=changelog,
                  label=label, genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith,
                  option=option)
        for e in res.get_all_edges(): e.source = res
        return res


# The act casting a vote.
class VoteAction(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 dateExecuted=None, changelog=None, label=None, genericAttribute=None, measure=None, sharedWith=None,
                 vote=None, usedBy=None, choice=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.dateExecuted = dateExecuted
        self.vote = vote if vote is not None else []
        self.usedBy = usedBy if usedBy is not None else []
        self.choice = choice if choice is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        dateExecuted = json.get("dateExecuted", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        vote = []
        usedBy = []
        choice = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "vote" or edge._type == "~vote": 
                    vote.append(edge)
                elif edge._type == "usedBy" or edge._type == "~usedBy": 
                    usedBy.append(edge)
                elif edge._type == "choice" or edge._type == "~choice": 
                    choice.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, dateExecuted=dateExecuted, changelog=changelog,
                  label=label, genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, vote=vote,
                  usedBy=usedBy, choice=choice)
        for e in res.get_all_edges(): e.source = res
        return res


# A Website is a set of related web pages and other items typically served from a single web domain
# and accessible via URLs.
class Website(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 itemType=None, url=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.itemType = itemType
        self.url = url

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        itemType = json.get("itemType", None)
        url = json.get("url", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, itemType=itemType, url=url, changelog=changelog,
                  label=label, genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        for e in res.get_all_edges(): e.source = res
        return res


# A written work, for instance a book, article or note. Doesn't have to be published.
class WrittenWork(Item):
    def __init__(self, dateAccessed=None, dateCreated=None, dateModified=None, deleted=None,
                 externalId=None, itemDescription=None, starred=None, version=None, uid=None, importJson=None,
                 title=None, abstract=None, datePublished=None, keyword=None, content=None, textContent=None,
                 transcript=None, itemType=None, changelog=None, label=None, genericAttribute=None, measure=None,
                 sharedWith=None, audio=None, citation=None, contentLocation=None, locationCreated=None, video=None,
                 writtenBy=None, file=None, recordedAt=None, review=None):
        super().__init__(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                         deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                         version=version, uid=uid, importJson=importJson, changelog=changelog, label=label,
                         genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith)
        self.title = title
        self.abstract = abstract
        self.datePublished = datePublished
        self.keyword = keyword
        self.content = content
        self.textContent = textContent
        self.transcript = transcript
        self.itemType = itemType
        self.audio = audio if audio is not None else []
        self.citation = citation if citation is not None else []
        self.contentLocation = contentLocation if contentLocation is not None else []
        self.locationCreated = locationCreated if locationCreated is not None else []
        self.video = video if video is not None else []
        self.writtenBy = writtenBy if writtenBy is not None else []
        self.file = file if file is not None else []
        self.recordedAt = recordedAt if recordedAt is not None else []
        self.review = review if review is not None else []

    @classmethod
    def from_json(cls, json):
        all_edges = json.get("allEdges", None)
        dateAccessed = json.get("dateAccessed", None)
        dateCreated = json.get("dateCreated", None)
        dateModified = json.get("dateModified", None)
        deleted = json.get("deleted", None)
        externalId = json.get("externalId", None)
        itemDescription = json.get("itemDescription", None)
        starred = json.get("starred", None)
        version = json.get("version", None)
        uid = json.get("uid", None)
        importJson = json.get("importJson", None)
        title = json.get("title", None)
        abstract = json.get("abstract", None)
        datePublished = json.get("datePublished", None)
        keyword = json.get("keyword", None)
        content = json.get("content", None)
        textContent = json.get("textContent", None)
        transcript = json.get("transcript", None)
        itemType = json.get("itemType", None)
       
        changelog = []
        label = []
        genericAttribute = []
        measure = []
        sharedWith = []
        audio = []
        citation = []
        contentLocation = []
        locationCreated = []
        video = []
        writtenBy = []
        file = []
        recordedAt = []
        review = []
        
        if all_edges is not None:
            for edge_json in all_edges:
                edge = Edge.from_json(edge_json)
                if edge._type == "changelog" or edge._type == "~changelog": 
                    changelog.append(edge)
                elif edge._type == "label" or edge._type == "~label": 
                    label.append(edge)
                elif edge._type == "genericAttribute" or edge._type == "~genericAttribute": 
                    genericAttribute.append(edge)
                elif edge._type == "measure" or edge._type == "~measure": 
                    measure.append(edge)
                elif edge._type == "sharedWith" or edge._type == "~sharedWith": 
                    sharedWith.append(edge)
                elif edge._type == "audio" or edge._type == "~audio": 
                    audio.append(edge)
                elif edge._type == "citation" or edge._type == "~citation": 
                    citation.append(edge)
                elif edge._type == "contentLocation" or edge._type == "~contentLocation": 
                    contentLocation.append(edge)
                elif edge._type == "locationCreated" or edge._type == "~locationCreated": 
                    locationCreated.append(edge)
                elif edge._type == "video" or edge._type == "~video": 
                    video.append(edge)
                elif edge._type == "writtenBy" or edge._type == "~writtenBy": 
                    writtenBy.append(edge)
                elif edge._type == "file" or edge._type == "~file": 
                    file.append(edge)
                elif edge._type == "recordedAt" or edge._type == "~recordedAt": 
                    recordedAt.append(edge)
                elif edge._type == "review" or edge._type == "~review": 
                    review.append(edge)
        
        res = cls(dateAccessed=dateAccessed, dateCreated=dateCreated, dateModified=dateModified,
                  deleted=deleted, externalId=externalId, itemDescription=itemDescription, starred=starred,
                  version=version, uid=uid, importJson=importJson, title=title, abstract=abstract,
                  datePublished=datePublished, keyword=keyword, content=content, textContent=textContent,
                  transcript=transcript, itemType=itemType, changelog=changelog, label=label,
                  genericAttribute=genericAttribute, measure=measure, sharedWith=sharedWith, audio=audio,
                  citation=citation, contentLocation=contentLocation, locationCreated=locationCreated, video=video,
                  writtenBy=writtenBy, file=file, recordedAt=recordedAt, review=review)
        for e in res.get_all_edges(): e.source = res
        return res