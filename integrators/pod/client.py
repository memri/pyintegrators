# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/pod.client.ipynb (unless otherwise specified).

__all__ = ['API_URL', 'PodClient']

# Cell
from ..data.itembase import Edge
from ..data.schema import *
from ..imports import *

# Cell
API_URL = "http://localhost:3030/v2"

# Cell
class PodClient:

    def __init__(self, url=API_URL, database_key=None, owner_key=None):
        self.url = url
        self.base_url = f"{url}/{owner_key}"
        self.test_connection(verbose=False)
        self.database_key=database_key
        self.owner_key=owner_key
        # self.local_db = DB()

    def test_connection(self, verbose=True):
        try:
            res = requests.get(self.url)
            if verbose: print("Succesfully connected to pod")
            return True
        except requests.exceptions.RequestException as e:
            print("Could no connect to backend")
            return False

#     def uid(self):
#         # TODO: REFACTOR
#         return int(1e5 + random.randint(0, 1e5))

    def create(self, node):
        if node.uid is None:
            print(f"Error, node {node} has no uid, not creating")
        try:
            body = {  "databaseKey": self.database_key, "payload":self.get_properties_json(node) }

            result = requests.post(f"{self.base_url}/create_item",
                                   json=body)
            if result.status_code != 200:
                print(result, result.content)
                return False
            else:
                return True
        except requests.exceptions.RequestException as e:
            print(e)
            return False

    def create_edges(self, edges):
        """Create edges between nodes, edges should be of format [{"_type": "friend", "_source": 1, "_target": 2}]"""
        edges_data = []
        for e in edges:
            src, target = e.source.uid, e.target.uid
            data = {"_source": src, "_target": target, "_type": e._type}
            if e.label is not None: data[LABEL] = e.label
            if e.sequence is not None: data[SEQUENCE] = e.sequence

            if e.reverse:
                data2 = copy(data)
                data2["_source"] = target
                data2["_target"] = src
                data2["_type"] = "~" + data2["_type"]
                edges_data.append(data2)

            edges_data.append(data)

        edges_data = {"databaseKey": self.database_key, "payload": {
                            "createItems": [], "updateItems": [], "createEdges": edges_data}}

        try:
            result = requests.post(f"{self.base_url}/bulk_action",
                                   json=edges_data)
            if result.status_code != 200:
                if "UNIQUE constraint failed" in str(result.content):
                    print(result.status_code, "Edge already exists")
                else:
                    print(result, result.content)
                return False
            else:
                return True
        except requests.exceptions.RequestException as e:
            print(e)
            return False

    def create_edge(self, edge):
        return self.create_edges([edge])

    def get(self, uid, expanded=True):
        if not expanded:
            return self._get_item_with_properties(uid)
        else:
            return self._get_item_expanded(uid)

    def _get_item_expanded(self, uid):
        body = {"payload": [uid],
                "databaseKey": self.database_key}
        try:
            result = requests.post(f"{self.base_url}/get_items_with_edges",
                                    json=body)
            if result.status_code != 200:
                print(result, result.content)
                return None
            else:
                json = result.json()[0]
                res =  self.item_from_json(json)
                return res

        except requests.exceptions.RequestException as e:
            print(e)
            return None

    def _get_item_with_properties(uid):
        try:
            result = requests.get(f"{self.base_url}/items/{uid}")
            if result.status_code != 200:
                print(result, result.content)
                return None
            else:
                json = result.json()
                if json == []:
                    return None
                else:
                    return json
        except requests.exceptions.RequestException as e:
            print(e)
            return None

    def get_properties_json(self, node):
        res = dict()
        for k,v in node.__dict__.items():
            if k[:1] != '_' and not (isinstance(v, list) and len(v)>0 and isinstance(v[0], Edge)) and v is not None:
                res[k] = v
        res["_type"] = node.__class__.__name__
        return res

    def update_item(self, node):
        data = self.get_properties_json(node)
        uid = data["uid"]
        body = {"payload": data,
                "databaseKey": self.database_key}

        try:
            result = requests.post(f"{self.base_url}/update_item",
                                  json=body)
            if result.status_code != 200:
                print(result, result.content)
        except requests.exceptions.RequestException as e:
            print(e)

    def search_by_fields(self, fields_data):

        body = {"payload": fields_data,
                "databaseKey": self.database_key}
        try:
            result = requests.post(f"{self.base_url}/search_by_fields",
                                   json=body)
            json =  result.json()
            return [self.item_from_json(item) for item in json]
        except requests.exceptions.RequestException as e:
            return None

    def item_from_json(self, json):
        indexer_class = json.get("indexerClass", None)
        constructor = get_constructor(json["_type"], indexer_class)
        return constructor.from_json(json)

    def get_properties(self, expanded):
        properties = copy(expanded)
        if ALL_EDGES in properties: del properties[ALL_EDGES]
        return properties

    def run_importer(self, uid, servicePayload):

        body = dict()
        body["databaseKey"] = servicePayload["databaseKey"]
        body["payload"] = {"uid": uid, "servicePayload": servicePayload}

        print(body)

        try:
            res = requests.post(f"{self.base_url}/run_importer", json=body)
            # res = requests.post(self.url)
            if res.status_code != 200:
                print(f"Failed to start importer on {url}:\n{res.status_code}: {res.text}")
            else:
                print("Starting importer")
        except requests.exceptions.RequestException as e:
            print("Error with calling importer {e}")