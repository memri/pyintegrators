# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/indexers.NoteListIndexer.Parser.ipynb (unless otherwise specified).

__all__ = ['HTMLListParser']

# Cell
import bs4
import random
from .util import *
from .notelist import *
from ...data.schema import *
from ...data.basic import *
from ...imports import *

# Cell
class HTMLListParser():
    '''Extracts lists from HTML data, generated by an HTML text editor like evernote'''

    def __init__(self):

        self.one_line_list_pa = ["buy", "read", "watch"]

        words    = ["do", "read", "watch", "buy", "listen"]
        prefixes = ["to", "to-", "to ", ""]

        self.single_item_list_patterns = [prefix+word for word in words for prefix in prefixes]

    def get_lists(self, note):
        """Extracts lists from a note"""

        text = note.content
        parsed = bs4.BeautifulSoup(text, 'html.parser')
        note.content=str(parsed)

        uls = get_toplevel_elements(text, "ul", parsed=parsed)
        ols = get_toplevel_elements(text, "ol", parsed=parsed)

        html_lists = [ULNoteList.from_data(title=None, content=str(x),
         textContent=remove_html(str(x)), note=note, span=get_span(note, x, parsed))
         for x in uls + ols]

        unformatted_lists = self.get_unformatted_lists(note, text, parsed)
        all_lists = html_lists + unformatted_lists

        for l in all_lists:
            note.add_edge("noteList", l)

        return all_lists

    def get_single_line_list(self, elem):
        """Get single list lists. An example could be: '<strong>read</strong>: great book title'"""
        ps = ["read", "buy", "watch", "do"]
        pat = "|".join([f"(<strong>|<em>|<u>)?{p}(</strong>|</em>|</u>)?:? ?" for p in ps])
        match = re.search(pat, str(elem), re.IGNORECASE)
        if match is None: return None, None

        cleaned_elem = remove_html(str(elem))

        cleaned_title = remove_html(match.group()) if match is not None else None

        if len(cleaned_elem) > len(cleaned_title) + 2:
            title = match.group()
            content = str(elem)[len(title):]
            return title, content
        else:
            return None, None

    def get_unformatted_lists(self, note, txt, parsed):
        """retrieve lists without <ul></ul> tags. We have two options:
                1) multiline lists prefixed with a title keyword (e.g. "Buy:" "Read:")
                2) single element single line lists"""

        toplevel_div = get_toplevel_elements(txt, "div")[0]
        ls = []

        for elem in toplevel_div.children:
            if elem.name == "div" and not is_newline_div(elem):

                children = get_children(elem)
                for i, child in enumerate(children):
                    # this extracts the lists that have a title and are not on a single line
                    if div_is_unstructured_list_title(child):
                        title = child
                        successors = list(children)[i+1:]
                        if len(successors) == 0:
                            continue
                        items = [x for x in find_till_double_br(successors) if not is_newline(str(x))]
                        items_str = [str(x) for x in items]
                        items_span = [get_span(note, x, parsed) for x in items_str]

                        span1 = get_span(note, title, parsed)
                        span2 = get_span(note, items[-1], parsed)
                        span = Span.from_data(startIdx=span1.startIdx, endIdx=span2.endIdx)
                        html_content = "".join(items_str)
                        l = INoteList.from_data(note=note, title=title, content=str(html_content), itemSpan=items_span, span=span)
                        ls.append(l)

                    else:
                        title, html_content = self.get_single_line_list(child)
                        if title is not None:
                            span = get_span(note, child, parsed)
                            itemSpan = [Span.from_data(startIdx=span.startIdx + len(str(title)), endIdx=span.endIdx)]
                            l = INoteList.from_data(note=note, title=title, content=str(html_content), itemSpan=itemSpan, span=span)
                            ls.append(l)
        return ls