# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/indexers.FaceClusteringIndexer.indexer.ipynb (unless otherwise specified).

__all__ = ['FaceClusteringIndexer']

# Cell
from integrators.indexers.faceclustering.models import *
from integrators.indexers.faceclustering.utils import *
from integrators.indexers.facerecognition.photo import *
from integrators.indexers.indexer import *
from integrators.data.basic import *
from integrators.data.schema import *
from integrators.imports import *
from integrators.pod.client import PodClient, DEFAULT_POD_ADDRESS

# Cell
from mmcv.runner import load_checkpoint
from collections import Counter
import cv2
import ipdb
import torch

# Cell
class FaceClusteringIndexer(IndexerBase):
    """Clusters faces on photos."""

    def __init__(self, *args, **kwargs):
        self.private = ["clustering_model"]
        self.clustering_model = FaceClusteringModel()
        super().__init__(*args, **kwargs)

    def get_data(self, client, indexer_run):
        photos = [d.expand(client) for d in get_indexer_run_data(client, indexer_run)]
        for p in photos: client._load_photo_data(p, size=640)
        photos = [p for p in photos if p.data is not None]
        return IndexerData(photos=photos)

    def create_cluster_items(self, crop_photos, pred_labels, min_cluster_size=2):
        c2p = {c: Person(firstName="unknown person") for c in set(pred_labels)
               if list(pred_labels).count(c) >= min_cluster_size }

        for photo, clust in zip(crop_photos, pred_labels):
            if clust in c2p:
                person = c2p[clust]
                person.add_edge("occurence", photo)
        people = list(c2p.values())
        return people

    def index(self, data, *args, **kwargs):
        photos = data.photos
        print(f"Indexing {len(photos)} photos")
        crop_photos, cluster_labels = self.clustering_model.run(photos)
        files = [c.file[0] for c in crop_photos]
        people = self.create_cluster_items(crop_photos, cluster_labels)
        return crop_photos + people + files
